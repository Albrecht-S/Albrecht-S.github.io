<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FLTK: Fl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FLTK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classFl.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classFl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Fl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classFl.html" title="The Fl is the FLTK global (static) class containing state information and global methods for the curr...">Fl</a> is the FLTK global (static) class containing state information and global methods for the current application.  
 <a href="classFl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Fl_8H_source.html">Fl.H</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a43e6e0bbbc03cad134d928d4edd48d1d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> { <br />
&#160;&#160;<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">OPTION_ARROW_FOCUS</a> = 0, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1dade29f22fc8066222d99ea3ccebc5e655">OPTION_VISIBLE_FOCUS</a>, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da2344bf14f80ecf5971e8aa4493a3858a">OPTION_DND_TEXT</a>, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1dae8214e42f77fe157297d61fdb818be2f">OPTION_SHOW_TOOLTIPS</a>, 
<br />
&#160;&#160;<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da01d530d6bc747eb0c192038eb802a8bd">OPTION_FNFC_USES_GTK</a>, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da5afc672e2e7e8f31ea9583b6c9ec6120">OPTION_PRINTER_USES_GTK</a>, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1dacf161d7667d109842094b2f2a08f0f3c">OPTION_SHOW_SCALING</a>, 
<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da220ebf62255fc47e5b5f213b410e2bc5">OPTION_LAST</a>
<br />
 }<tr class="memdesc:a43e6e0bbbc03cad134d928d4edd48d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerator for global FLTK options.  <a href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a43e6e0bbbc03cad134d928d4edd48d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aeec1fc58b2ded93866e75fc0f317b284"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aeec1fc58b2ded93866e75fc0f317b284">abi_check</a> (const int val=<a class="el" href="Enumerations_8H.html#a619cd27e13a15a7b1b5ead0932dd3912">FL_ABI_VERSION</a>)</td></tr>
<tr class="memdesc:aeec1fc58b2ded93866e75fc0f317b284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the runtime library ABI version is correct.  <a href="#aeec1fc58b2ded93866e75fc0f317b284">More...</a><br /></td></tr>
<tr class="separator:aeec1fc58b2ded93866e75fc0f317b284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa664880d0a1fab25b7bb53803112093"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aaa664880d0a1fab25b7bb53803112093">abi_version</a> ()</td></tr>
<tr class="memdesc:aaa664880d0a1fab25b7bb53803112093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compiled-in value of the FL_ABI_VERSION constant.  <a href="#aaa664880d0a1fab25b7bb53803112093">More...</a><br /></td></tr>
<tr class="separator:aaa664880d0a1fab25b7bb53803112093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff1ee2c6afa6463293a2188a44b00b5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#afff1ee2c6afa6463293a2188a44b00b5">add_awake_handler_</a> (<a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a>, void *)</td></tr>
<tr class="memdesc:afff1ee2c6afa6463293a2188a44b00b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>.  <a href="#afff1ee2c6afa6463293a2188a44b00b5">More...</a><br /></td></tr>
<tr class="separator:afff1ee2c6afa6463293a2188a44b00b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b689a9e42582fe6e87f7c7eb1dce94f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7b689a9e42582fe6e87f7c7eb1dce94f">add_check</a> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a7b689a9e42582fe6e87f7c7eb1dce94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK will call this callback just before it flushes the display and waits for events.  <a href="#a7b689a9e42582fe6e87f7c7eb1dce94f">More...</a><br /></td></tr>
<tr class="separator:a7b689a9e42582fe6e87f7c7eb1dce94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01ff0cf95384f8255fa80edcbe1432d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gaa01ff0cf95384f8255fa80edcbe1432d">add_clipboard_notify</a> (<a class="el" href="group__callback__functions.html#gae5e26cbad23960ff7ce4d50d82c74750">Fl_Clipboard_Notify_Handler</a> <a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a>, void *data=0)</td></tr>
<tr class="memdesc:gaa01ff0cf95384f8255fa80edcbe1432d"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK will call the registered callback whenever there is a change to the selection buffer or the clipboard.  <a href="group__fl__clipboard.html#gaa01ff0cf95384f8255fa80edcbe1432d">More...</a><br /></td></tr>
<tr class="separator:gaa01ff0cf95384f8255fa80edcbe1432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8905e303e45e846b8ce77168f4cf7afe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a8905e303e45e846b8ce77168f4cf7afe">add_fd</a> (int fd, int when, <a class="el" href="group__callback__functions.html#ga2cff1a51089da7653ab49bae499dfbf4">Fl_FD_Handler</a> cb, void *=0)</td></tr>
<tr class="memdesc:a8905e303e45e846b8ce77168f4cf7afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds file descriptor fd to listen to.  <a href="#a8905e303e45e846b8ce77168f4cf7afe">More...</a><br /></td></tr>
<tr class="separator:a8905e303e45e846b8ce77168f4cf7afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5e7aac775b05f0c985bb352f5add24"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7e5e7aac775b05f0c985bb352f5add24">add_fd</a> (int fd, <a class="el" href="group__callback__functions.html#ga2cff1a51089da7653ab49bae499dfbf4">Fl_FD_Handler</a> cb, void *=0)</td></tr>
<tr class="memdesc:a7e5e7aac775b05f0c985bb352f5add24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds file descriptor fd to listen to.  <a href="#a7e5e7aac775b05f0c985bb352f5add24">More...</a><br /></td></tr>
<tr class="separator:a7e5e7aac775b05f0c985bb352f5add24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d39bda7362e444afa41166c478b904"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gae2d39bda7362e444afa41166c478b904">add_handler</a> (<a class="el" href="group__callback__functions.html#ga188f6b1dd8e78ccc91c013fe5c6bba74">Fl_Event_Handler</a> <a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a>)</td></tr>
<tr class="memdesc:gae2d39bda7362e444afa41166c478b904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a function to parse unrecognized events.  <a href="group__fl__events.html#gae2d39bda7362e444afa41166c478b904">More...</a><br /></td></tr>
<tr class="separator:gae2d39bda7362e444afa41166c478b904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7a1b5d18c2f073238a8466a62a3e7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a">add_idle</a> (<a class="el" href="group__callback__functions.html#gac9d2aab1d3142308450e2da09716013e">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr class="memdesc:a4e7a1b5d18c2f073238a8466a62a3e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback function that is called every time by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> and also makes it act as though the timeout is zero (this makes <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> return immediately, so if it is in a loop it is called repeatedly, and thus the idle fucntion is called repeatedly).  <a href="#a4e7a1b5d18c2f073238a8466a62a3e7a">More...</a><br /></td></tr>
<tr class="separator:a4e7a1b5d18c2f073238a8466a62a3e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87427a41cb546d97236c244abaff8bd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gad87427a41cb546d97236c244abaff8bd">add_system_handler</a> (<a class="el" href="group__callback__functions.html#ga0cd86d9a18073304779213e82747ac8a">Fl_System_Handler</a> <a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a>, void *data)</td></tr>
<tr class="memdesc:gad87427a41cb546d97236c244abaff8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a function to intercept system events.  <a href="group__fl__events.html#gad87427a41cb546d97236c244abaff8bd">More...</a><br /></td></tr>
<tr class="separator:gad87427a41cb546d97236c244abaff8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e63eb7cec3a27fa360e66c6e2b2e52"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52">add_timeout</a> (double t, <a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a23e63eb7cec3a27fa360e66c6e2b2e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a one-shot timeout callback.  <a href="#a23e63eb7cec3a27fa360e66c6e2b2e52">More...</a><br /></td></tr>
<tr class="separator:a23e63eb7cec3a27fa360e66c6e2b2e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600b0ef3dcd4311850ab4b2988d5d6d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7600b0ef3dcd4311850ab4b2988d5d6d">api_version</a> ()</td></tr>
<tr class="memdesc:a7600b0ef3dcd4311850ab4b2988d5d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compiled-in value of the FL_API_VERSION constant.  <a href="#a7600b0ef3dcd4311850ab4b2988d5d6d">More...</a><br /></td></tr>
<tr class="separator:a7600b0ef3dcd4311850ab4b2988d5d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1576b8c9ca3e900daaa5c36ca0e7ae48"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a1576b8c9ca3e900daaa5c36ca0e7ae48">arg</a> (int argc, char **argv, int &amp;i)</td></tr>
<tr class="memdesc:a1576b8c9ca3e900daaa5c36ca0e7ae48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single switch from <code>argv</code>, starting at word <code>i</code>.  <a href="#a1576b8c9ca3e900daaa5c36ca0e7ae48">More...</a><br /></td></tr>
<tr class="separator:a1576b8c9ca3e900daaa5c36ca0e7ae48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115903daf3593748cdd36a5e78e74534"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534">args</a> (int argc, char **argv, int &amp;i, <a class="el" href="group__callback__functions.html#ga6cb5354ccaa2a6619f2408dbb5203f3b">Fl_Args_Handler</a> cb=0)</td></tr>
<tr class="memdesc:a115903daf3593748cdd36a5e78e74534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command line switches using the <code>cb</code> argument handler.  <a href="#a115903daf3593748cdd36a5e78e74534">More...</a><br /></td></tr>
<tr class="separator:a115903daf3593748cdd36a5e78e74534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb24179ad2642412f4042863fe23645"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a6fb24179ad2642412f4042863fe23645">args</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a6fb24179ad2642412f4042863fe23645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all command line switches matching standard FLTK options only.  <a href="#a6fb24179ad2642412f4042863fe23645">More...</a><br /></td></tr>
<tr class="separator:a6fb24179ad2642412f4042863fe23645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9e8f440ce2ca05b047c620f75af13cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb">awake</a> (void *message=0)</td></tr>
<tr class="memdesc:gae9e8f440ce2ca05b047c620f75af13cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message pointer to the main thread, causing any pending <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> call to terminate so that the main thread can retrieve the message and any pending redraws can be processed.  <a href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb">More...</a><br /></td></tr>
<tr class="separator:gae9e8f440ce2ca05b047c620f75af13cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a404bcaf6641369e0725627d881556"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga22a404bcaf6641369e0725627d881556">awake</a> (<a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a> cb, void *message=0)</td></tr>
<tr class="memdesc:ga22a404bcaf6641369e0725627d881556"><td class="mdescLeft">&#160;</td><td class="mdescRight">See void awake(void* message=0).  <a href="group__fl__multithread.html#ga22a404bcaf6641369e0725627d881556">More...</a><br /></td></tr>
<tr class="separator:ga22a404bcaf6641369e0725627d881556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422da0dfc6aa51721e7c9a6ccf5b90ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef">background</a> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:a422da0dfc6aa51721e7c9a6ccf5b90ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to black to white.  <a href="#a422da0dfc6aa51721e7c9a6ccf5b90ef">More...</a><br /></td></tr>
<tr class="separator:a422da0dfc6aa51721e7c9a6ccf5b90ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d4c4557a2127bfc46abe15feed3be2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2">background2</a> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:a98d4c4557a2127bfc46abe15feed3be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the alternative background color.  <a href="#a98d4c4557a2127bfc46abe15feed3be2">More...</a><br /></td></tr>
<tr class="separator:a98d4c4557a2127bfc46abe15feed3be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b55ce634002a2743c24c4c4db7cbdd4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga5b55ce634002a2743c24c4c4db7cbdd4">belowmouse</a> ()</td></tr>
<tr class="memdesc:ga5b55ce634002a2743c24c4c4db7cbdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the widget that is below the mouse.  <a href="group__fl__events.html#ga5b55ce634002a2743c24c4c4db7cbdd4">More...</a><br /></td></tr>
<tr class="separator:ga5b55ce634002a2743c24c4c4db7cbdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5c497679a904863019edf5375293bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga5a5c497679a904863019edf5375293bf">belowmouse</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:ga5a5c497679a904863019edf5375293bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that is below the mouse.  <a href="group__fl__events.html#ga5a5c497679a904863019edf5375293bf">More...</a><br /></td></tr>
<tr class="separator:ga5a5c497679a904863019edf5375293bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426f19d77abf3a13b98930095a987bbb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a426f19d77abf3a13b98930095a987bbb">box_border_radius_max</a> ()</td></tr>
<tr class="memdesc:a426f19d77abf3a13b98930095a987bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum border radius of all "rounded" boxtypes in pixels.  <a href="#a426f19d77abf3a13b98930095a987bbb">More...</a><br /></td></tr>
<tr class="separator:a426f19d77abf3a13b98930095a987bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654c4fb93b0487c5b590c4fc9f1e8aee"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a654c4fb93b0487c5b590c4fc9f1e8aee">box_border_radius_max</a> (int R)</td></tr>
<tr class="memdesc:a654c4fb93b0487c5b590c4fc9f1e8aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum border radius of all "rounded" boxtypes in pixels.  <a href="#a654c4fb93b0487c5b590c4fc9f1e8aee">More...</a><br /></td></tr>
<tr class="separator:a654c4fb93b0487c5b590c4fc9f1e8aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaecb51f270a5b42ad31f0e8091635dd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aaaecb51f270a5b42ad31f0e8091635dd">box_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>)</td></tr>
<tr class="memdesc:aaaecb51f270a5b42ad31f0e8091635dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the drawing color to be used for the background of a box.  <a href="#aaaecb51f270a5b42ad31f0e8091635dd">More...</a><br /></td></tr>
<tr class="separator:aaaecb51f270a5b42ad31f0e8091635dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af739a06d44dc94d09015ed1940b9f066"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#af739a06d44dc94d09015ed1940b9f066">box_dh</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:af739a06d44dc94d09015ed1940b9f066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height offset for the given boxtype.  <a href="#af739a06d44dc94d09015ed1940b9f066">More...</a><br /></td></tr>
<tr class="separator:af739a06d44dc94d09015ed1940b9f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a327ed95a8c2533ca4eee659bf3d557"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9a327ed95a8c2533ca4eee659bf3d557">box_dw</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:a9a327ed95a8c2533ca4eee659bf3d557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width offset for the given boxtype.  <a href="#a9a327ed95a8c2533ca4eee659bf3d557">More...</a><br /></td></tr>
<tr class="separator:a9a327ed95a8c2533ca4eee659bf3d557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2971f20fe3595fd8f77fe73d4eb89594"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a2971f20fe3595fd8f77fe73d4eb89594">box_dx</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:a2971f20fe3595fd8f77fe73d4eb89594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the X offset for the given boxtype.  <a href="#a2971f20fe3595fd8f77fe73d4eb89594">More...</a><br /></td></tr>
<tr class="separator:a2971f20fe3595fd8f77fe73d4eb89594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbd0a2a5c43a30893dec05e8d34dc15"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15">box_dy</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:a9fbd0a2a5c43a30893dec05e8d34dc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Y offset for the given boxtype.  <a href="#a9fbd0a2a5c43a30893dec05e8d34dc15">More...</a><br /></td></tr>
<tr class="separator:a9fbd0a2a5c43a30893dec05e8d34dc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd8ae7763ccae17628af3e49c00a9ec"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a4fd8ae7763ccae17628af3e49c00a9ec">box_shadow_width</a> ()</td></tr>
<tr class="memdesc:a4fd8ae7763ccae17628af3e49c00a9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the box shadow width of all "shadow" boxtypes in pixels.  <a href="#a4fd8ae7763ccae17628af3e49c00a9ec">More...</a><br /></td></tr>
<tr class="separator:a4fd8ae7763ccae17628af3e49c00a9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfefd9ca200dcc16d9ed7e46d54ce626"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#acfefd9ca200dcc16d9ed7e46d54ce626">box_shadow_width</a> (int W)</td></tr>
<tr class="memdesc:acfefd9ca200dcc16d9ed7e46d54ce626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the box shadow width of all "shadow" boxtypes in pixels.  <a href="#acfefd9ca200dcc16d9ed7e46d54ce626">More...</a><br /></td></tr>
<tr class="separator:acfefd9ca200dcc16d9ed7e46d54ce626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a1f7fcf75353908cc96b0edb928dd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#gae5a1f7fcf75353908cc96b0edb928dd9">cairo_autolink_context</a> (bool alink)</td></tr>
<tr class="memdesc:gae5a1f7fcf75353908cc96b0edb928dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">when FLTK_HAVE_CAIRO is defined and <a class="el" href="group__group__cairo.html#ga9a52d25377797666e43a46b520c485ac" title="Gets the current autolink mode for cairo support. ">cairo_autolink_context()</a> is true, any current window dc is linked to a current cairo context.  <a href="group__group__cairo.html#gae5a1f7fcf75353908cc96b0edb928dd9">More...</a><br /></td></tr>
<tr class="separator:gae5a1f7fcf75353908cc96b0edb928dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a52d25377797666e43a46b520c485ac"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#ga9a52d25377797666e43a46b520c485ac">cairo_autolink_context</a> ()</td></tr>
<tr class="memdesc:ga9a52d25377797666e43a46b520c485ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current autolink mode for cairo support.  <a href="group__group__cairo.html#ga9a52d25377797666e43a46b520c485ac">More...</a><br /></td></tr>
<tr class="separator:ga9a52d25377797666e43a46b520c485ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ff6bfde35cd1d8a050d18cdc2f24af"><td class="memItemLeft" align="right" valign="top">static cairo_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#ga71ff6bfde35cd1d8a050d18cdc2f24af">cairo_cc</a> ()</td></tr>
<tr class="memdesc:ga71ff6bfde35cd1d8a050d18cdc2f24af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current cairo context linked with a fltk window.  <a href="group__group__cairo.html#ga71ff6bfde35cd1d8a050d18cdc2f24af">More...</a><br /></td></tr>
<tr class="separator:ga71ff6bfde35cd1d8a050d18cdc2f24af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd5ba3321a80408a1460e114e2e5f99"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#ga2bd5ba3321a80408a1460e114e2e5f99">cairo_cc</a> (cairo_t *c, bool own=false)</td></tr>
<tr class="memdesc:ga2bd5ba3321a80408a1460e114e2e5f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current cairo context to <code>c</code>.  <a href="group__group__cairo.html#ga2bd5ba3321a80408a1460e114e2e5f99">More...</a><br /></td></tr>
<tr class="separator:ga2bd5ba3321a80408a1460e114e2e5f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc793671da89c45c42c32ff7a777b5e8"><td class="memItemLeft" align="right" valign="top">static cairo_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__cairo.html#gabc793671da89c45c42c32ff7a777b5e8">cairo_make_current</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *<a class="el" href="group__fl__screen.html#ga7aba4252407f539aa6d821551aaba5ff">w</a>)</td></tr>
<tr class="memdesc:gabc793671da89c45c42c32ff7a777b5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a corresponding cairo context for window <em>wi</em>.  <a href="group__group__cairo.html#gabc793671da89c45c42c32ff7a777b5e8">More...</a><br /></td></tr>
<tr class="separator:gabc793671da89c45c42c32ff7a777b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbb83f1d52001c152ccf8415e3ee6f0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0">check</a> ()</td></tr>
<tr class="memdesc:a1dbb83f1d52001c152ccf8415e3ee6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as Fl::wait(0).  <a href="#a1dbb83f1d52001c152ccf8415e3ee6f0">More...</a><br /></td></tr>
<tr class="separator:a1dbb83f1d52001c152ccf8415e3ee6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cbd31083b47836cbe00ffb7006a4d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4">clear_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> const *<a class="el" href="group__fl__screen.html#ga7aba4252407f539aa6d821551aaba5ff">w</a>)</td></tr>
<tr class="memdesc:gad3cbd31083b47836cbe00ffb7006a4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a widget pointer <em>in</em> the watch list.  <a href="group__fl__del__widget.html#gad3cbd31083b47836cbe00ffb7006a4d4">More...</a><br /></td></tr>
<tr class="separator:gad3cbd31083b47836cbe00ffb7006a4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20ba398998726e719f85dde0b78e1480"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga20ba398998726e719f85dde0b78e1480">clipboard_contains</a> (const char *type)</td></tr>
<tr class="memdesc:ga20ba398998726e719f85dde0b78e1480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non 0 if the clipboard contains data matching <code>type</code>.  <a href="group__fl__clipboard.html#ga20ba398998726e719f85dde0b78e1480">More...</a><br /></td></tr>
<tr class="separator:ga20ba398998726e719f85dde0b78e1480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b619b0bccac6da8cdc55e6bb8a8d52"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga79b619b0bccac6da8cdc55e6bb8a8d52">compose</a> (int &amp;del)</td></tr>
<tr class="memdesc:ga79b619b0bccac6da8cdc55e6bb8a8d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any text editing widget should call this for each FL_KEYBOARD event.  <a href="group__fl__events.html#ga79b619b0bccac6da8cdc55e6bb8a8d52">More...</a><br /></td></tr>
<tr class="separator:ga79b619b0bccac6da8cdc55e6bb8a8d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee29b04437dacb960cace49e84d62606"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gaee29b04437dacb960cace49e84d62606">compose_reset</a> ()</td></tr>
<tr class="memdesc:gaee29b04437dacb960cace49e84d62606"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user moves the cursor, be sure to call <a class="el" href="group__fl__events.html#gaee29b04437dacb960cace49e84d62606" title="If the user moves the cursor, be sure to call Fl::compose_reset(). ">Fl::compose_reset()</a>.  <a href="group__fl__events.html#gaee29b04437dacb960cace49e84d62606">More...</a><br /></td></tr>
<tr class="separator:gaee29b04437dacb960cace49e84d62606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe46352043c48d38b090203db417c398"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gafe46352043c48d38b090203db417c398">copy</a> (const char *stuff, int len, int destination=0, const char *type=<a class="el" href="group__fl__clipboard.html#ga96135e2dd04bfd737085ef5fb3d824e1">Fl::clipboard_plain_text</a>)</td></tr>
<tr class="memdesc:gafe46352043c48d38b090203db417c398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data pointed to by <code>stuff</code> to the selection buffer (<code>destination</code> is 0), the clipboard (<code>destination</code> is 1), or both (<code>destination</code> is 2).  <a href="group__fl__clipboard.html#gafe46352043c48d38b090203db417c398">More...</a><br /></td></tr>
<tr class="separator:gafe46352043c48d38b090203db417c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45391ff5a25464a6e40658b58bf3ef98"><td class="memItemLeft" align="right" valign="top"><a id="a45391ff5a25464a6e40658b58bf3ef98"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a45391ff5a25464a6e40658b58bf3ef98">damage</a> (int d)</td></tr>
<tr class="memdesc:a45391ff5a25464a6e40658b58bf3ef98"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true then <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">flush()</a> will do something. <br /></td></tr>
<tr class="separator:a45391ff5a25464a6e40658b58bf3ef98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e4de1119ebb169c8a8de4c81a4cb59"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ac5e4de1119ebb169c8a8de4c81a4cb59">damage</a> ()</td></tr>
<tr class="memdesc:ac5e4de1119ebb169c8a8de4c81a4cb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true then <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">flush()</a> will do something.  <a href="#ac5e4de1119ebb169c8a8de4c81a4cb59">More...</a><br /></td></tr>
<tr class="separator:ac5e4de1119ebb169c8a8de4c81a4cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd064730c5ea01306754bc5c35df24f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gadd064730c5ea01306754bc5c35df24f9">default_atclose</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *, void *)</td></tr>
<tr class="memdesc:gadd064730c5ea01306754bc5c35df24f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback for window widgets.  <a href="group__fl__windows.html#gadd064730c5ea01306754bc5c35df24f9">More...</a><br /></td></tr>
<tr class="separator:gadd064730c5ea01306754bc5c35df24f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609413ac47ba433d1e7da8678a27164f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f">delete_widget</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *<a class="el" href="group__fl__screen.html#ga7aba4252407f539aa6d821551aaba5ff">w</a>)</td></tr>
<tr class="memdesc:ga609413ac47ba433d1e7da8678a27164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a widget for deletion at the next call to the event loop.  <a href="group__fl__del__widget.html#ga609413ac47ba433d1e7da8678a27164f">More...</a><br /></td></tr>
<tr class="separator:ga609413ac47ba433d1e7da8678a27164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81f13a94b3448057b4f556c33b7c3779"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga81f13a94b3448057b4f556c33b7c3779">disable_im</a> ()</td></tr>
<tr class="memdesc:ga81f13a94b3448057b4f556c33b7c3779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the system input methods facilities.  <a href="group__fl__events.html#ga81f13a94b3448057b4f556c33b7c3779">More...</a><br /></td></tr>
<tr class="separator:ga81f13a94b3448057b4f556c33b7c3779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6847e1b7dd9628821656933ca8e79d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7c6847e1b7dd9628821656933ca8e79d">display</a> (const char *)</td></tr>
<tr class="memdesc:a7c6847e1b7dd9628821656933ca8e79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the X display to use for all windows.  <a href="#a7c6847e1b7dd9628821656933ca8e79d">More...</a><br /></td></tr>
<tr class="separator:a7c6847e1b7dd9628821656933ca8e79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42026e276b8e83312ce58b264d1d4dcc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga42026e276b8e83312ce58b264d1d4dcc">dnd</a> ()</td></tr>
<tr class="memdesc:ga42026e276b8e83312ce58b264d1d4dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate a Drag And Drop operation.  <a href="group__fl__clipboard.html#ga42026e276b8e83312ce58b264d1d4dcc">More...</a><br /></td></tr>
<tr class="separator:ga42026e276b8e83312ce58b264d1d4dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53430e25b53f3b608193fa4009898463"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a53430e25b53f3b608193fa4009898463">dnd_text_ops</a> (int v)</td></tr>
<tr class="memdesc:a53430e25b53f3b608193fa4009898463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether drag and drop text operations are supported.  <a href="#a53430e25b53f3b608193fa4009898463">More...</a><br /></td></tr>
<tr class="separator:a53430e25b53f3b608193fa4009898463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae157def51e4dabe5f75298b676ddea2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aae157def51e4dabe5f75298b676ddea2">dnd_text_ops</a> ()</td></tr>
<tr class="memdesc:aae157def51e4dabe5f75298b676ddea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether drag and drop text operations are supported.  <a href="#aae157def51e4dabe5f75298b676ddea2">More...</a><br /></td></tr>
<tr class="separator:aae157def51e4dabe5f75298b676ddea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838010444986ae57301d6e8289d2dfbb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga838010444986ae57301d6e8289d2dfbb">do_widget_deletion</a> ()</td></tr>
<tr class="memdesc:ga838010444986ae57301d6e8289d2dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes widgets previously scheduled for deletion.  <a href="group__fl__del__widget.html#ga838010444986ae57301d6e8289d2dfbb">More...</a><br /></td></tr>
<tr class="separator:ga838010444986ae57301d6e8289d2dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56cf568ee94318b50d2b2da0aa3031b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad56cf568ee94318b50d2b2da0aa3031b">draw_box_active</a> ()</td></tr>
<tr class="memdesc:ad56cf568ee94318b50d2b2da0aa3031b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the currently drawn box is active or inactive.  <a href="#ad56cf568ee94318b50d2b2da0aa3031b">More...</a><br /></td></tr>
<tr class="separator:ad56cf568ee94318b50d2b2da0aa3031b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee84c3cdff0dec085bf666c7d062499"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a8ee84c3cdff0dec085bf666c7d062499">draw_GL_text_with_textures</a> (int val)</td></tr>
<tr class="memdesc:a8ee84c3cdff0dec085bf666c7d062499"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets whether OpenGL uses textures to draw all text.  <a href="#a8ee84c3cdff0dec085bf666c7d062499">More...</a><br /></td></tr>
<tr class="separator:a8ee84c3cdff0dec085bf666c7d062499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297d9a7b41053abd23423fa7b2e3b3ad"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a297d9a7b41053abd23423fa7b2e3b3ad">draw_GL_text_with_textures</a> ()</td></tr>
<tr class="memdesc:a297d9a7b41053abd23423fa7b2e3b3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether whether OpenGL uses textures to draw all text.  <a href="#a297d9a7b41053abd23423fa7b2e3b3ad">More...</a><br /></td></tr>
<tr class="separator:a297d9a7b41053abd23423fa7b2e3b3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf17501d78d3927d96ec979bfbf81294"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gaaf17501d78d3927d96ec979bfbf81294">enable_im</a> ()</td></tr>
<tr class="memdesc:gaaf17501d78d3927d96ec979bfbf81294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the system input methods facilities.  <a href="group__fl__events.html#gaaf17501d78d3927d96ec979bfbf81294">More...</a><br /></td></tr>
<tr class="separator:gaaf17501d78d3927d96ec979bfbf81294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7595e274aaebaa23982125a1363d13f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gac7595e274aaebaa23982125a1363d13f">event</a> ()</td></tr>
<tr class="memdesc:gac7595e274aaebaa23982125a1363d13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last event that was processed.  <a href="group__fl__events.html#gac7595e274aaebaa23982125a1363d13f">More...</a><br /></td></tr>
<tr class="separator:gac7595e274aaebaa23982125a1363d13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee32cc3de557d5a1cc81a1eab944929"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1ee32cc3de557d5a1cc81a1eab944929">event_alt</a> ()</td></tr>
<tr class="memdesc:ga1ee32cc3de557d5a1cc81a1eab944929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Alt key is pressed.  <a href="group__fl__events.html#ga1ee32cc3de557d5a1cc81a1eab944929">More...</a><br /></td></tr>
<tr class="separator:ga1ee32cc3de557d5a1cc81a1eab944929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae6d99ceb1a2afb8a1dc4455ac941cd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga7ae6d99ceb1a2afb8a1dc4455ac941cd">event_button</a> ()</td></tr>
<tr class="memdesc:ga7ae6d99ceb1a2afb8a1dc4455ac941cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets which particular mouse button caused the current event.  <a href="group__fl__events.html#ga7ae6d99ceb1a2afb8a1dc4455ac941cd">More...</a><br /></td></tr>
<tr class="separator:ga7ae6d99ceb1a2afb8a1dc4455ac941cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec5fa15a7ea5229cbff8dd507130d46"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga6ec5fa15a7ea5229cbff8dd507130d46">event_button1</a> ()</td></tr>
<tr class="memdesc:ga6ec5fa15a7ea5229cbff8dd507130d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if mouse button 1 is currently held down.  <a href="group__fl__events.html#ga6ec5fa15a7ea5229cbff8dd507130d46">More...</a><br /></td></tr>
<tr class="separator:ga6ec5fa15a7ea5229cbff8dd507130d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85ae7c11308de6e4653a860729dec77"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gad85ae7c11308de6e4653a860729dec77">event_button2</a> ()</td></tr>
<tr class="memdesc:gad85ae7c11308de6e4653a860729dec77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if button 2 is currently held down.  <a href="group__fl__events.html#gad85ae7c11308de6e4653a860729dec77">More...</a><br /></td></tr>
<tr class="separator:gad85ae7c11308de6e4653a860729dec77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70f54fbed74f801495575939dc787361"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga70f54fbed74f801495575939dc787361">event_button3</a> ()</td></tr>
<tr class="memdesc:ga70f54fbed74f801495575939dc787361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if button 3 is currently held down.  <a href="group__fl__events.html#ga70f54fbed74f801495575939dc787361">More...</a><br /></td></tr>
<tr class="separator:ga70f54fbed74f801495575939dc787361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee06c25589974fafb1c8df8d0e2c7c80"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gaee06c25589974fafb1c8df8d0e2c7c80">event_buttons</a> ()</td></tr>
<tr class="memdesc:gaee06c25589974fafb1c8df8d0e2c7c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse buttons state bits; if non-zero, then at least one button is pressed now.  <a href="group__fl__events.html#gaee06c25589974fafb1c8df8d0e2c7c80">More...</a><br /></td></tr>
<tr class="separator:gaee06c25589974fafb1c8df8d0e2c7c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa31b53b34bd43ee107806a3bbc640d1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1">event_clicks</a> ()</td></tr>
<tr class="memdesc:gafa31b53b34bd43ee107806a3bbc640d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non zero if we had a double click event.  <a href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1">More...</a><br /></td></tr>
<tr class="separator:gafa31b53b34bd43ee107806a3bbc640d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0531622eb47fab712faedd43eab886d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga0531622eb47fab712faedd43eab886d9">event_clicks</a> (int i)</td></tr>
<tr class="memdesc:ga0531622eb47fab712faedd43eab886d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually sets the number returned by <a class="el" href="group__fl__events.html#gafa31b53b34bd43ee107806a3bbc640d1" title="Returns non zero if we had a double click event. ">Fl::event_clicks()</a>.  <a href="group__fl__events.html#ga0531622eb47fab712faedd43eab886d9">More...</a><br /></td></tr>
<tr class="separator:ga0531622eb47fab712faedd43eab886d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5964867d1d60792c45bb28082c257624"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga5964867d1d60792c45bb28082c257624">event_clipboard</a> ()</td></tr>
<tr class="memdesc:ga5964867d1d60792c45bb28082c257624"><td class="mdescLeft">&#160;</td><td class="mdescRight">During an FL_PASTE event of non-textual data, returns a pointer to the pasted data.  <a href="group__fl__events.html#ga5964867d1d60792c45bb28082c257624">More...</a><br /></td></tr>
<tr class="separator:ga5964867d1d60792c45bb28082c257624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c229daff88166ff492b1332c1568899"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga4c229daff88166ff492b1332c1568899">event_clipboard_type</a> ()</td></tr>
<tr class="memdesc:ga4c229daff88166ff492b1332c1568899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the pasted data during an FL_PASTE event.  <a href="group__fl__events.html#ga4c229daff88166ff492b1332c1568899">More...</a><br /></td></tr>
<tr class="separator:ga4c229daff88166ff492b1332c1568899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73da625a4d77f730da5e0bd0e8823be9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga73da625a4d77f730da5e0bd0e8823be9">event_command</a> ()</td></tr>
<tr class="memdesc:ga73da625a4d77f730da5e0bd0e8823be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the FL_COMMAND key is pressed, either FL_CTRL or on OSX FL_META.  <a href="group__fl__events.html#ga73da625a4d77f730da5e0bd0e8823be9">More...</a><br /></td></tr>
<tr class="separator:ga73da625a4d77f730da5e0bd0e8823be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace54a534aad4a88dac170871a5bcbe1a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gace54a534aad4a88dac170871a5bcbe1a">event_ctrl</a> ()</td></tr>
<tr class="memdesc:gace54a534aad4a88dac170871a5bcbe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Control key is pressed.  <a href="group__fl__events.html#gace54a534aad4a88dac170871a5bcbe1a">More...</a><br /></td></tr>
<tr class="separator:gace54a534aad4a88dac170871a5bcbe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8bd62d8fdacef87c56ed3a22cdcebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafc8bd62d8fdacef87c56ed3a22cdcebc">event_dispatch</a> (<a class="el" href="group__callback__functions.html#ga2fa80da592860bc4c0c1a06d36262601">Fl_Event_Dispatch</a> d)</td></tr>
<tr class="memdesc:gafc8bd62d8fdacef87c56ed3a22cdcebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new event dispatch function.  <a href="group__fl__events.html#gafc8bd62d8fdacef87c56ed3a22cdcebc">More...</a><br /></td></tr>
<tr class="separator:gafc8bd62d8fdacef87c56ed3a22cdcebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad45688b3e262a38151320a4059e04d"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="group__callback__functions.html#ga2fa80da592860bc4c0c1a06d36262601">Fl_Event_Dispatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafad45688b3e262a38151320a4059e04d">event_dispatch</a> ()</td></tr>
<tr class="memdesc:gafad45688b3e262a38151320a4059e04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current event dispatch function. <br /></td></tr>
<tr class="separator:gafad45688b3e262a38151320a4059e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd50231ad95aaf23a23e9db42cccb42e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gadd50231ad95aaf23a23e9db42cccb42e">event_dx</a> ()</td></tr>
<tr class="memdesc:gadd50231ad95aaf23a23e9db42cccb42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current horizontal mouse scrolling associated with the FL_MOUSEWHEEL event.  <a href="group__fl__events.html#gadd50231ad95aaf23a23e9db42cccb42e">More...</a><br /></td></tr>
<tr class="separator:gadd50231ad95aaf23a23e9db42cccb42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4704bd4e93b6471321d6ac84b0df97e5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga4704bd4e93b6471321d6ac84b0df97e5">event_dy</a> ()</td></tr>
<tr class="memdesc:ga4704bd4e93b6471321d6ac84b0df97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current vertical mouse scrolling associated with the FL_MOUSEWHEEL event.  <a href="group__fl__events.html#ga4704bd4e93b6471321d6ac84b0df97e5">More...</a><br /></td></tr>
<tr class="separator:ga4704bd4e93b6471321d6ac84b0df97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277f38696ffa53b63325b13ac51976bb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga277f38696ffa53b63325b13ac51976bb">event_inside</a> (int, int, int, int)</td></tr>
<tr class="memdesc:ga277f38696ffa53b63325b13ac51976bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the mouse event is inside the given rectangle.  <a href="group__fl__events.html#ga277f38696ffa53b63325b13ac51976bb">More...</a><br /></td></tr>
<tr class="separator:ga277f38696ffa53b63325b13ac51976bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143c28ca9e41cb919be1c4c72227a475"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga143c28ca9e41cb919be1c4c72227a475">event_inside</a> (const <a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:ga143c28ca9e41cb919be1c4c72227a475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the mouse event is inside a given child widget.  <a href="group__fl__events.html#ga143c28ca9e41cb919be1c4c72227a475">More...</a><br /></td></tr>
<tr class="separator:ga143c28ca9e41cb919be1c4c72227a475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f3bafeb9fbae98c3b7cc6f5326e582"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gae4f3bafeb9fbae98c3b7cc6f5326e582">event_is_click</a> ()</td></tr>
<tr class="memdesc:gae4f3bafeb9fbae98c3b7cc6f5326e582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the mouse has not moved far enough and not enough time has passed since the last FL_PUSH or FL_KEYBOARD event for it to be considered a "drag" rather than a "click".  <a href="group__fl__events.html#gae4f3bafeb9fbae98c3b7cc6f5326e582">More...</a><br /></td></tr>
<tr class="separator:gae4f3bafeb9fbae98c3b7cc6f5326e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ba811a19462788094768ed98798120"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga08ba811a19462788094768ed98798120">event_is_click</a> (int i)</td></tr>
<tr class="memdesc:ga08ba811a19462788094768ed98798120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the value returned by <a class="el" href="group__fl__events.html#gae4f3bafeb9fbae98c3b7cc6f5326e582" title="Returns non-zero if the mouse has not moved far enough and not enough time has passed since the last ...">Fl::event_is_click()</a>.  <a href="group__fl__events.html#ga08ba811a19462788094768ed98798120">More...</a><br /></td></tr>
<tr class="separator:ga08ba811a19462788094768ed98798120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac131e3cd5ca674cc022b1f77233449"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1ac131e3cd5ca674cc022b1f77233449">event_key</a> ()</td></tr>
<tr class="memdesc:ga1ac131e3cd5ca674cc022b1f77233449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets which key on the keyboard was last pushed.  <a href="group__fl__events.html#ga1ac131e3cd5ca674cc022b1f77233449">More...</a><br /></td></tr>
<tr class="separator:ga1ac131e3cd5ca674cc022b1f77233449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12be48f03872da009734f557d1e761bc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga12be48f03872da009734f557d1e761bc">event_key</a> (int key)</td></tr>
<tr class="memdesc:ga12be48f03872da009734f557d1e761bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>key</code> was held down (or pressed) <em>during</em> the last event.  <a href="group__fl__events.html#ga12be48f03872da009734f557d1e761bc">More...</a><br /></td></tr>
<tr class="separator:ga12be48f03872da009734f557d1e761bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f2de89fbdf59ad2cd4dca93f472911"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga38f2de89fbdf59ad2cd4dca93f472911">event_length</a> ()</td></tr>
<tr class="memdesc:ga38f2de89fbdf59ad2cd4dca93f472911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the text in <a class="el" href="group__fl__events.html#ga6647c55948fe1d8be9367267529e9c54" title="Returns the text associated with the current event, including FL_PASTE or FL_DND_RELEASE events...">Fl::event_text()</a>.  <a href="group__fl__events.html#ga38f2de89fbdf59ad2cd4dca93f472911">More...</a><br /></td></tr>
<tr class="separator:ga38f2de89fbdf59ad2cd4dca93f472911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec41d640b647e422b88331015ab660d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gadec41d640b647e422b88331015ab660d">event_original_key</a> ()</td></tr>
<tr class="memdesc:gadec41d640b647e422b88331015ab660d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the keycode of the last key event, regardless of the NumLock state.  <a href="group__fl__events.html#gadec41d640b647e422b88331015ab660d">More...</a><br /></td></tr>
<tr class="separator:gadec41d640b647e422b88331015ab660d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd68dc8a592e9a2a41b42cb7e3a30060"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gabd68dc8a592e9a2a41b42cb7e3a30060">event_shift</a> ()</td></tr>
<tr class="memdesc:gabd68dc8a592e9a2a41b42cb7e3a30060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the Shift key is pressed.  <a href="group__fl__events.html#gabd68dc8a592e9a2a41b42cb7e3a30060">More...</a><br /></td></tr>
<tr class="separator:gabd68dc8a592e9a2a41b42cb7e3a30060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa17a5b4d8d9163631c88142e60447ed"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed">event_state</a> ()</td></tr>
<tr class="memdesc:gafa17a5b4d8d9163631c88142e60447ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the keyboard and mouse button states of the last event.  <a href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed">More...</a><br /></td></tr>
<tr class="separator:gafa17a5b4d8d9163631c88142e60447ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a32c24a501002db29b66008a175a558"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga3a32c24a501002db29b66008a175a558">event_state</a> (int mask)</td></tr>
<tr class="memdesc:ga3a32c24a501002db29b66008a175a558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if any of the passed event state bits are turned on.  <a href="group__fl__events.html#ga3a32c24a501002db29b66008a175a558">More...</a><br /></td></tr>
<tr class="separator:ga3a32c24a501002db29b66008a175a558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6647c55948fe1d8be9367267529e9c54"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga6647c55948fe1d8be9367267529e9c54">event_text</a> ()</td></tr>
<tr class="memdesc:ga6647c55948fe1d8be9367267529e9c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the text associated with the current event, including FL_PASTE or FL_DND_RELEASE events.  <a href="group__fl__events.html#ga6647c55948fe1d8be9367267529e9c54">More...</a><br /></td></tr>
<tr class="separator:ga6647c55948fe1d8be9367267529e9c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91585fcbaa1e79f7452fd2d16a82136e"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga91585fcbaa1e79f7452fd2d16a82136e">event_x</a> ()</td></tr>
<tr class="memdesc:ga91585fcbaa1e79f7452fd2d16a82136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position of the event relative to the <a class="el" href="classFl__Window.html" title="This widget produces an actual window. ">Fl_Window</a> it was passed to. <br /></td></tr>
<tr class="separator:ga91585fcbaa1e79f7452fd2d16a82136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c40bd0d2960354c9778fdb65a2b720d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga4c40bd0d2960354c9778fdb65a2b720d">event_x_root</a> ()</td></tr>
<tr class="memdesc:ga4c40bd0d2960354c9778fdb65a2b720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position on the screen of the event.  <a href="group__fl__events.html#ga4c40bd0d2960354c9778fdb65a2b720d">More...</a><br /></td></tr>
<tr class="separator:ga4c40bd0d2960354c9778fdb65a2b720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192a0c5a37f33b9d117a69f20977c2a1"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga192a0c5a37f33b9d117a69f20977c2a1">event_y</a> ()</td></tr>
<tr class="memdesc:ga192a0c5a37f33b9d117a69f20977c2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position of the event relative to the <a class="el" href="classFl__Window.html" title="This widget produces an actual window. ">Fl_Window</a> it was passed to. <br /></td></tr>
<tr class="separator:ga192a0c5a37f33b9d117a69f20977c2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9801003f911eae0e49bf52b875dcaaa5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga9801003f911eae0e49bf52b875dcaaa5">event_y_root</a> ()</td></tr>
<tr class="memdesc:ga9801003f911eae0e49bf52b875dcaaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse position on the screen of the event.  <a href="group__fl__events.html#ga9801003f911eae0e49bf52b875dcaaa5">More...</a><br /></td></tr>
<tr class="separator:ga9801003f911eae0e49bf52b875dcaaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3130407bc1c11f9b7f2a9c43a87a1599"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga3130407bc1c11f9b7f2a9c43a87a1599">first_window</a> ()</td></tr>
<tr class="memdesc:ga3130407bc1c11f9b7f2a9c43a87a1599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first top-level window in the list of shown() windows.  <a href="group__fl__windows.html#ga3130407bc1c11f9b7f2a9c43a87a1599">More...</a><br /></td></tr>
<tr class="separator:ga3130407bc1c11f9b7f2a9c43a87a1599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac1e48dd4e0fa7431776c1e754e273e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gabac1e48dd4e0fa7431776c1e754e273e">first_window</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:gabac1e48dd4e0fa7431776c1e754e273e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the window that is returned by <a class="el" href="group__fl__windows.html#ga3130407bc1c11f9b7f2a9c43a87a1599" title="Returns the first top-level window in the list of shown() windows. ">first_window()</a>.  <a href="group__fl__windows.html#gabac1e48dd4e0fa7431776c1e754e273e">More...</a><br /></td></tr>
<tr class="separator:gabac1e48dd4e0fa7431776c1e754e273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d29d807ea3874b8bb16f7457f64bdc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc">flush</a> ()</td></tr>
<tr class="memdesc:a08d29d807ea3874b8bb16f7457f64bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all the windows that need it to be redrawn and graphics forced out through the pipes.  <a href="#a08d29d807ea3874b8bb16f7457f64bdc">More...</a><br /></td></tr>
<tr class="separator:a08d29d807ea3874b8bb16f7457f64bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0e9836db43268979e0b3a999583b7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga7f0e9836db43268979e0b3a999583b7f">focus</a> ()</td></tr>
<tr class="memdesc:ga7f0e9836db43268979e0b3a999583b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current <a class="el" href="group__fl__events.html#ga7f0e9836db43268979e0b3a999583b7f" title="Gets the current Fl::focus() widget. ">Fl::focus()</a> widget.  <a href="group__fl__events.html#ga7f0e9836db43268979e0b3a999583b7f">More...</a><br /></td></tr>
<tr class="separator:ga7f0e9836db43268979e0b3a999583b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6eb61b05d03838978c6a1a8016ce7a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga1f6eb61b05d03838978c6a1a8016ce7a">focus</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:ga1f6eb61b05d03838978c6a1a8016ce7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that will receive FL_KEYBOARD events.  <a href="group__fl__events.html#ga1f6eb61b05d03838978c6a1a8016ce7a">More...</a><br /></td></tr>
<tr class="separator:ga1f6eb61b05d03838978c6a1a8016ce7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf02f998cce7ebb3331def57fccc8a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7">foreground</a> (<a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:afbf02f998cce7ebb3331def57fccc8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes fl_color(FL_FOREGROUND_COLOR).  <a href="#afbf02f998cce7ebb3331def57fccc8a7">More...</a><br /></td></tr>
<tr class="separator:afbf02f998cce7ebb3331def57fccc8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68ad6c3474fb71b3db5a44658b60b14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gae68ad6c3474fb71b3db5a44658b60b14">free_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, int overlay=0)</td></tr>
<tr class="memdesc:gae68ad6c3474fb71b3db5a44658b60b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the specified color from the colormap, if applicable.  <a href="group__fl__attributes.html#gae68ad6c3474fb71b3db5a44658b60b14">More...</a><br /></td></tr>
<tr class="separator:gae68ad6c3474fb71b3db5a44658b60b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837ed3f58be4ad9ed3949e31678bc8fe"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a837ed3f58be4ad9ed3949e31678bc8fe">get_awake_handler_</a> (<a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a> &amp;, void *&amp;)</td></tr>
<tr class="memdesc:a837ed3f58be4ad9ed3949e31678bc8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the last stored awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>.  <a href="#a837ed3f58be4ad9ed3949e31678bc8fe">More...</a><br /></td></tr>
<tr class="separator:a837ed3f58be4ad9ed3949e31678bc8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d53b0d7749d7c3d053e72ee2a5a816"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__callback__functions.html#gacb24a62f521a0e02cd7872a3bfbf3855">Fl_Box_Draw_F</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a62d53b0d7749d7c3d053e72ee2a5a816">get_boxtype</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>)</td></tr>
<tr class="memdesc:a62d53b0d7749d7c3d053e72ee2a5a816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current box drawing function for the specified box type.  <a href="#a62d53b0d7749d7c3d053e72ee2a5a816">More...</a><br /></td></tr>
<tr class="separator:a62d53b0d7749d7c3d053e72ee2a5a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9977c7ef50c9f51efd0d7909020a16da"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga9977c7ef50c9f51efd0d7909020a16da">get_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i)</td></tr>
<tr class="memdesc:ga9977c7ef50c9f51efd0d7909020a16da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RGB value(s) for the given FLTK color index.  <a href="group__fl__attributes.html#ga9977c7ef50c9f51efd0d7909020a16da">More...</a><br /></td></tr>
<tr class="separator:ga9977c7ef50c9f51efd0d7909020a16da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb8db6ea9968f546687f89a4ec336a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga4eb8db6ea9968f546687f89a4ec336a0">get_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;red, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;green, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> &amp;blue)</td></tr>
<tr class="memdesc:ga4eb8db6ea9968f546687f89a4ec336a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RGB value(s) for the given FLTK color index.  <a href="group__fl__attributes.html#ga4eb8db6ea9968f546687f89a4ec336a0">More...</a><br /></td></tr>
<tr class="separator:ga4eb8db6ea9968f546687f89a4ec336a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac822bdf31f387b4dfc520e8b261b6b1a"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gac822bdf31f387b4dfc520e8b261b6b1a">get_font</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>)</td></tr>
<tr class="memdesc:gac822bdf31f387b4dfc520e8b261b6b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the string for this face.  <a href="group__fl__attributes.html#gac822bdf31f387b4dfc520e8b261b6b1a">More...</a><br /></td></tr>
<tr class="separator:gac822bdf31f387b4dfc520e8b261b6b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b30b9bc92f6a263928d028de07fe23"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga90b30b9bc92f6a263928d028de07fe23">get_font_name</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, int *attributes=0)</td></tr>
<tr class="memdesc:ga90b30b9bc92f6a263928d028de07fe23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a human-readable string describing the family of this face.  <a href="group__fl__attributes.html#ga90b30b9bc92f6a263928d028de07fe23">More...</a><br /></td></tr>
<tr class="separator:ga90b30b9bc92f6a263928d028de07fe23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435176ea0a7ed5b8e5eb65792cfbcb20"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga435176ea0a7ed5b8e5eb65792cfbcb20">get_font_sizes</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, int *&amp;sizep)</td></tr>
<tr class="memdesc:ga435176ea0a7ed5b8e5eb65792cfbcb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of sizes in <code>sizep</code>.  <a href="group__fl__attributes.html#ga435176ea0a7ed5b8e5eb65792cfbcb20">More...</a><br /></td></tr>
<tr class="separator:ga435176ea0a7ed5b8e5eb65792cfbcb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7049319eed772c8a22cf2c0eb484a39"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gab7049319eed772c8a22cf2c0eb484a39">get_key</a> (int key)</td></tr>
<tr class="memdesc:gab7049319eed772c8a22cf2c0eb484a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <code>key</code> is held down <em>now</em>.  <a href="group__fl__events.html#gab7049319eed772c8a22cf2c0eb484a39">More...</a><br /></td></tr>
<tr class="separator:gab7049319eed772c8a22cf2c0eb484a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace49495f2b947065bb140e5023d14954"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gace49495f2b947065bb140e5023d14954">get_mouse</a> (int &amp;, int &amp;)</td></tr>
<tr class="memdesc:gace49495f2b947065bb140e5023d14954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return where the mouse is on the screen by doing a round-trip query to the server.  <a href="group__fl__events.html#gace49495f2b947065bb140e5023d14954">More...</a><br /></td></tr>
<tr class="separator:gace49495f2b947065bb140e5023d14954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0a7958eebf1491685040be87490947"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aed0a7958eebf1491685040be87490947">get_system_colors</a> ()</td></tr>
<tr class="memdesc:aed0a7958eebf1491685040be87490947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the user preference colors from the system and use them to call <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR). ">Fl::foreground()</a>, <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>, and <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color. ">Fl::background2()</a>.  <a href="#aed0a7958eebf1491685040be87490947">More...</a><br /></td></tr>
<tr class="separator:aed0a7958eebf1491685040be87490947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a149f42db33b581e1dbe47ffb626abf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7a149f42db33b581e1dbe47ffb626abf">gl_visual</a> (int, int *alist=0)</td></tr>
<tr class="memdesc:a7a149f42db33b581e1dbe47ffb626abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does the same thing as <a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly. ">Fl::visual(int)</a> but also requires OpenGL drawing to work.  <a href="#a7a149f42db33b581e1dbe47ffb626abf">More...</a><br /></td></tr>
<tr class="separator:a7a149f42db33b581e1dbe47ffb626abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga100705a8107397cfde7318aa34019739"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga100705a8107397cfde7318aa34019739">grab</a> ()</td></tr>
<tr class="memdesc:ga100705a8107397cfde7318aa34019739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the window that currently receives all events.  <a href="group__fl__windows.html#ga100705a8107397cfde7318aa34019739">More...</a><br /></td></tr>
<tr class="separator:ga100705a8107397cfde7318aa34019739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0918f4dabb87b5e429ad4e0e38239845"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845">grab</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:ga0918f4dabb87b5e429ad4e0e38239845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the window to grab.  <a href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845">More...</a><br /></td></tr>
<tr class="separator:ga0918f4dabb87b5e429ad4e0e38239845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59edda7c6a51ff2cb4673f21b739088"><td class="memItemLeft" align="right" valign="top"><a id="ab59edda7c6a51ff2cb4673f21b739088"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ab59edda7c6a51ff2cb4673f21b739088">grab</a> (<a class="el" href="classFl__Window.html">Fl_Window</a> &amp;win)</td></tr>
<tr class="memdesc:ab59edda7c6a51ff2cb4673f21b739088"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845" title="Selects the window to grab. ">grab(Fl_Window*)</a> <br /></td></tr>
<tr class="separator:ab59edda7c6a51ff2cb4673f21b739088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f42d75cf9b3e79bbe39e1041a657cdf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a> ()</td></tr>
<tr class="memdesc:ga7f42d75cf9b3e79bbe39e1041a657cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the height in pixels of the main screen work area.  <a href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">More...</a><br /></td></tr>
<tr class="separator:ga7f42d75cf9b3e79bbe39e1041a657cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064a4028b27d7da1238a6e5280582abf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga064a4028b27d7da1238a6e5280582abf">handle</a> (int, <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:ga064a4028b27d7da1238a6e5280582abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle events from the window system.  <a href="group__fl__events.html#ga064a4028b27d7da1238a6e5280582abf">More...</a><br /></td></tr>
<tr class="separator:ga064a4028b27d7da1238a6e5280582abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c55e69277a2197ca3763122ff2f78af"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga9c55e69277a2197ca3763122ff2f78af">handle_</a> (int, <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:ga9c55e69277a2197ca3763122ff2f78af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle events from the window system.  <a href="group__fl__events.html#ga9c55e69277a2197ca3763122ff2f78af">More...</a><br /></td></tr>
<tr class="separator:ga9c55e69277a2197ca3763122ff2f78af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab2ac86a4368147c075dd6750b03546"><td class="memItemLeft" align="right" valign="top"><a id="a3ab2ac86a4368147c075dd6750b03546"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3ab2ac86a4368147c075dd6750b03546">has_check</a> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a3ab2ac86a4368147c075dd6750b03546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the check exists and has not been called yet, 0 otherwise. <br /></td></tr>
<tr class="separator:a3ab2ac86a4368147c075dd6750b03546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f5d04106f8369655e51bd27e4953cd"><td class="memItemLeft" align="right" valign="top"><a id="a41f5d04106f8369655e51bd27e4953cd"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a41f5d04106f8369655e51bd27e4953cd">has_idle</a> (<a class="el" href="group__callback__functions.html#gac9d2aab1d3142308450e2da09716013e">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr class="memdesc:a41f5d04106f8369655e51bd27e4953cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified idle callback is currently installed. <br /></td></tr>
<tr class="separator:a41f5d04106f8369655e51bd27e4953cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3164768ec950db81396b81ef42f8ba2"><td class="memItemLeft" align="right" valign="top"><a id="ae3164768ec950db81396b81ef42f8ba2"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae3164768ec950db81396b81ef42f8ba2">has_timeout</a> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:ae3164768ec950db81396b81ef42f8ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the timeout exists and has not been called yet. <br /></td></tr>
<tr class="separator:ae3164768ec950db81396b81ef42f8ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac203e6ef8108d4a9de6008d4b536307e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ac203e6ef8108d4a9de6008d4b536307e">insertion_point_location</a> (int <a class="el" href="group__fl__screen.html#gaed836eacded3467aa838d02a1c55e3ab">x</a>, int <a class="el" href="group__fl__screen.html#gafa36572c1f755f8a9783efc351f19021">y</a>, int height)</td></tr>
<tr class="memdesc:ac203e6ef8108d4a9de6008d4b536307e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets window coordinates and height of insertion point.  <a href="#ac203e6ef8108d4a9de6008d4b536307e">More...</a><br /></td></tr>
<tr class="separator:ac203e6ef8108d4a9de6008d4b536307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c26018ae654d07ec1aa73e35b244a4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a19c26018ae654d07ec1aa73e35b244a4">is_scheme</a> (const char *name)</td></tr>
<tr class="memdesc:a19c26018ae654d07ec1aa73e35b244a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the current scheme is the given name.  <a href="#a19c26018ae654d07ec1aa73e35b244a4">More...</a><br /></td></tr>
<tr class="separator:a19c26018ae654d07ec1aa73e35b244a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76864ed7f65c861378f094ebb34955b9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga76864ed7f65c861378f094ebb34955b9">keyboard_screen_scaling</a> (int value)</td></tr>
<tr class="memdesc:ga76864ed7f65c861378f094ebb34955b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the possibility to scale all windows by ctrl/+/-/0/ or cmd/+/-/0/.  <a href="group__fl__screen.html#ga76864ed7f65c861378f094ebb34955b9">More...</a><br /></td></tr>
<tr class="separator:ga76864ed7f65c861378f094ebb34955b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2">lock</a> ()</td></tr>
<tr class="memdesc:gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method blocks the current thread until it can safely access FLTK widgets and data.  <a href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2">More...</a><br /></td></tr>
<tr class="separator:gaf6f46de66cc183bc5b38cd364aca4cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d29df12fea1b116d70e237eb471798"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ab2d29df12fea1b116d70e237eb471798">menu_linespacing</a> ()</td></tr>
<tr class="memdesc:ab2d29df12fea1b116d70e237eb471798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default line spacing used by menus.  <a href="#ab2d29df12fea1b116d70e237eb471798">More...</a><br /></td></tr>
<tr class="separator:ab2d29df12fea1b116d70e237eb471798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaabff6af047485f864dbc66cf5978d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a6eaabff6af047485f864dbc66cf5978d">menu_linespacing</a> (int H)</td></tr>
<tr class="memdesc:a6eaabff6af047485f864dbc66cf5978d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default line spacing used by menus.  <a href="#a6eaabff6af047485f864dbc66cf5978d">More...</a><br /></td></tr>
<tr class="separator:a6eaabff6af047485f864dbc66cf5978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0938156f04e1babebaa8eb75a8d0fce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gaf0938156f04e1babebaa8eb75a8d0fce">modal</a> ()</td></tr>
<tr class="memdesc:gaf0938156f04e1babebaa8eb75a8d0fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-most <a class="el" href="group__fl__windows.html#gaf0938156f04e1babebaa8eb75a8d0fce" title="Returns the top-most modal() window currently shown. ">modal()</a> window currently shown.  <a href="group__fl__windows.html#gaf0938156f04e1babebaa8eb75a8d0fce">More...</a><br /></td></tr>
<tr class="separator:gaf0938156f04e1babebaa8eb75a8d0fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46df67455d96ee45e51f59263c6bf0ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Window.html">Fl_Window</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga46df67455d96ee45e51f59263c6bf0ea">next_window</a> (const <a class="el" href="classFl__Window.html">Fl_Window</a> *)</td></tr>
<tr class="memdesc:ga46df67455d96ee45e51f59263c6bf0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next top-level window in the list of shown() windows.  <a href="group__fl__windows.html#ga46df67455d96ee45e51f59263c6bf0ea">More...</a><br /></td></tr>
<tr class="separator:ga46df67455d96ee45e51f59263c6bf0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc49722be45fb56cad89c7c067eda5e3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">option</a> (<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> opt)</td></tr>
<tr class="memdesc:abc49722be45fb56cad89c7c067eda5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK library options management.  <a href="#abc49722be45fb56cad89c7c067eda5e3">More...</a><br /></td></tr>
<tr class="separator:abc49722be45fb56cad89c7c067eda5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b040cad5d6fc04bb139877015091c16"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16">option</a> (<a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a> opt, bool val)</td></tr>
<tr class="memdesc:a9b040cad5d6fc04bb139877015091c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override an option while the application is running.  <a href="#a9b040cad5d6fc04bb139877015091c16">More...</a><br /></td></tr>
<tr class="separator:a9b040cad5d6fc04bb139877015091c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217dd709bed0d62a652625d505918fc6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a217dd709bed0d62a652625d505918fc6">own_colormap</a> ()</td></tr>
<tr class="memdesc:a217dd709bed0d62a652625d505918fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes FLTK use its <a href="fltk-colormap.png">own colormap</a>.  <a href="#a217dd709bed0d62a652625d505918fc6">More...</a><br /></td></tr>
<tr class="separator:a217dd709bed0d62a652625d505918fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3eff1864c4cf8e90d899d8a632e93e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gac3eff1864c4cf8e90d899d8a632e93e5">paste</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;receiver, int source, const char *type=<a class="el" href="group__fl__clipboard.html#ga96135e2dd04bfd737085ef5fb3d824e1">Fl::clipboard_plain_text</a>)</td></tr>
<tr class="memdesc:gac3eff1864c4cf8e90d899d8a632e93e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pastes the data from the selection buffer (<code>source</code> is 0) or the clipboard (<code>source</code> is 1) into <code>receiver</code>.  <a href="group__fl__clipboard.html#gac3eff1864c4cf8e90d899d8a632e93e5">More...</a><br /></td></tr>
<tr class="separator:gac3eff1864c4cf8e90d899d8a632e93e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5cf78a03d0d619052dea890d97c71e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga9d5cf78a03d0d619052dea890d97c71e">paste</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;receiver)</td></tr>
<tr class="memdesc:ga9d5cf78a03d0d619052dea890d97c71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward compatibility only.  <a href="group__fl__clipboard.html#ga9d5cf78a03d0d619052dea890d97c71e">More...</a><br /></td></tr>
<tr class="separator:ga9d5cf78a03d0d619052dea890d97c71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e47798ab952686bc084e061a4a88da7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a2e47798ab952686bc084e061a4a88da7">program_should_quit</a> ()</td></tr>
<tr class="memdesc:a2e47798ab952686bc084e061a4a88da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero when a request for program termination was received and accepted.  <a href="#a2e47798ab952686bc084e061a4a88da7">More...</a><br /></td></tr>
<tr class="separator:a2e47798ab952686bc084e061a4a88da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f75f8111bd47ba00f2b0888831dbd8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7f75f8111bd47ba00f2b0888831dbd8c">program_should_quit</a> (int should_i)</td></tr>
<tr class="memdesc:a7f75f8111bd47ba00f2b0888831dbd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate to the FLTK library whether a program termination request was received and accepted.  <a href="#a7f75f8111bd47ba00f2b0888831dbd8c">More...</a><br /></td></tr>
<tr class="separator:a7f75f8111bd47ba00f2b0888831dbd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd24382935bf08b56b1532dfe80da25"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gadcd24382935bf08b56b1532dfe80da25">pushed</a> ()</td></tr>
<tr class="memdesc:gadcd24382935bf08b56b1532dfe80da25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the widget that is being pushed.  <a href="group__fl__events.html#gadcd24382935bf08b56b1532dfe80da25">More...</a><br /></td></tr>
<tr class="separator:gadcd24382935bf08b56b1532dfe80da25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b269dff4e6b30a876ec46b6f911fac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga83b269dff4e6b30a876ec46b6f911fac">pushed</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:ga83b269dff4e6b30a876ec46b6f911fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the widget that is being pushed.  <a href="group__fl__events.html#ga83b269dff4e6b30a876ec46b6f911fac">More...</a><br /></td></tr>
<tr class="separator:ga83b269dff4e6b30a876ec46b6f911fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c27ca2833030aa15482bd06dbfc5959"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3c27ca2833030aa15482bd06dbfc5959">readqueue</a> ()</td></tr>
<tr class="memdesc:a3c27ca2833030aa15482bd06dbfc5959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the default callback queue and returns the first widget.  <a href="#a3c27ca2833030aa15482bd06dbfc5959">More...</a><br /></td></tr>
<tr class="separator:a3c27ca2833030aa15482bd06dbfc5959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a0cf2dd925cc6c4074d32a36fcf98f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f">ready</a> ()</td></tr>
<tr class="memdesc:a41a0cf2dd925cc6c4074d32a36fcf98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is similar to <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0). ">Fl::check()</a> except this does <em>not</em> call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> or any callbacks, which is useful if your program is in a state where such callbacks are illegal.  <a href="#a41a0cf2dd925cc6c4074d32a36fcf98f">More...</a><br /></td></tr>
<tr class="separator:a41a0cf2dd925cc6c4074d32a36fcf98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec5e7939d214882da2d31c894a5bad7"><td class="memItemLeft" align="right" valign="top"><a id="aeec5e7939d214882da2d31c894a5bad7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aeec5e7939d214882da2d31c894a5bad7">redraw</a> ()</td></tr>
<tr class="memdesc:aeec5e7939d214882da2d31c894a5bad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redraws all widgets. <br /></td></tr>
<tr class="separator:aeec5e7939d214882da2d31c894a5bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656023b0db49ae9b88e277ccdb27ce1b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a656023b0db49ae9b88e277ccdb27ce1b">release</a> ()</td></tr>
<tr class="memdesc:a656023b0db49ae9b88e277ccdb27ce1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the current grabbed window, equals grab(0).  <a href="#a656023b0db49ae9b88e277ccdb27ce1b">More...</a><br /></td></tr>
<tr class="separator:a656023b0db49ae9b88e277ccdb27ce1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1426329d09de561319d4555018d9d1a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2">release_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;<a class="el" href="group__fl__screen.html#ga7aba4252407f539aa6d821551aaba5ff">w</a>)</td></tr>
<tr class="memdesc:ga1426329d09de561319d4555018d9d1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a widget pointer from the watch list.  <a href="group__fl__del__widget.html#ga1426329d09de561319d4555018d9d1a2">More...</a><br /></td></tr>
<tr class="separator:ga1426329d09de561319d4555018d9d1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf6b5b7bfe06b268e8c51ec11acf378"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3cf6b5b7bfe06b268e8c51ec11acf378">reload_scheme</a> ()</td></tr>
<tr class="memdesc:a3cf6b5b7bfe06b268e8c51ec11acf378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by scheme according to scheme name.  <a href="#a3cf6b5b7bfe06b268e8c51ec11acf378">More...</a><br /></td></tr>
<tr class="separator:a3cf6b5b7bfe06b268e8c51ec11acf378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee3d6bb1c70f5202e7cc9cb87cd515"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a43ee3d6bb1c70f5202e7cc9cb87cd515">remove_check</a> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a43ee3d6bb1c70f5202e7cc9cb87cd515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a check callback.  <a href="#a43ee3d6bb1c70f5202e7cc9cb87cd515">More...</a><br /></td></tr>
<tr class="separator:a43ee3d6bb1c70f5202e7cc9cb87cd515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd837e512f22cec57f6fad2362e27350"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gafd837e512f22cec57f6fad2362e27350">remove_clipboard_notify</a> (<a class="el" href="group__callback__functions.html#gae5e26cbad23960ff7ce4d50d82c74750">Fl_Clipboard_Notify_Handler</a> <a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a>)</td></tr>
<tr class="memdesc:gafd837e512f22cec57f6fad2362e27350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop calling the specified callback when there are changes to the selection buffer or the clipboard. <br /></td></tr>
<tr class="separator:gafd837e512f22cec57f6fad2362e27350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e75c1a559e3415c5304c37235af831"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a71e75c1a559e3415c5304c37235af831">remove_fd</a> (int, int when)</td></tr>
<tr class="memdesc:a71e75c1a559e3415c5304c37235af831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a file descriptor handler.  <a href="#a71e75c1a559e3415c5304c37235af831">More...</a><br /></td></tr>
<tr class="separator:a71e75c1a559e3415c5304c37235af831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4ece44a4e07f7d95950b665047a807"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a5f4ece44a4e07f7d95950b665047a807">remove_fd</a> (int)</td></tr>
<tr class="memdesc:a5f4ece44a4e07f7d95950b665047a807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a file descriptor handler.  <a href="#a5f4ece44a4e07f7d95950b665047a807">More...</a><br /></td></tr>
<tr class="separator:a5f4ece44a4e07f7d95950b665047a807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057451b4da1df58193521d8206f29edf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#ga057451b4da1df58193521d8206f29edf">remove_handler</a> (<a class="el" href="group__callback__functions.html#ga188f6b1dd8e78ccc91c013fe5c6bba74">Fl_Event_Handler</a> <a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a>)</td></tr>
<tr class="memdesc:ga057451b4da1df58193521d8206f29edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added event handler.  <a href="group__fl__events.html#ga057451b4da1df58193521d8206f29edf">More...</a><br /></td></tr>
<tr class="separator:ga057451b4da1df58193521d8206f29edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43903f998a07e1cca7ba199c8ed25d9b"><td class="memItemLeft" align="right" valign="top"><a id="a43903f998a07e1cca7ba199c8ed25d9b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a43903f998a07e1cca7ba199c8ed25d9b">remove_idle</a> (<a class="el" href="group__callback__functions.html#gac9d2aab1d3142308450e2da09716013e">Fl_Idle_Handler</a> cb, void *data=0)</td></tr>
<tr class="memdesc:a43903f998a07e1cca7ba199c8ed25d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified idle callback, if it is installed. <br /></td></tr>
<tr class="separator:a43903f998a07e1cca7ba199c8ed25d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5de0c3883a255c20ef432031f8746a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gad5de0c3883a255c20ef432031f8746a7">remove_system_handler</a> (<a class="el" href="group__callback__functions.html#ga0cd86d9a18073304779213e82747ac8a">Fl_System_Handler</a> <a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a>)</td></tr>
<tr class="memdesc:gad5de0c3883a255c20ef432031f8746a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously added system event handler.  <a href="group__fl__events.html#gad5de0c3883a255c20ef432031f8746a7">More...</a><br /></td></tr>
<tr class="separator:gad5de0c3883a255c20ef432031f8746a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a950f0585de6416eb4fee2365a1578f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9a950f0585de6416eb4fee2365a1578f">remove_timeout</a> (<a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:a9a950f0585de6416eb4fee2365a1578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a timeout callback.  <a href="#a9a950f0585de6416eb4fee2365a1578f">More...</a><br /></td></tr>
<tr class="separator:a9a950f0585de6416eb4fee2365a1578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5373d1d50c2b0ba38280d78bb6d2628"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628">repeat_timeout</a> (double t, <a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>, void *=0)</td></tr>
<tr class="memdesc:ae5373d1d50c2b0ba38280d78bb6d2628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate timing.  <a href="#ae5373d1d50c2b0ba38280d78bb6d2628">More...</a><br /></td></tr>
<tr class="separator:ae5373d1d50c2b0ba38280d78bb6d2628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe815086e4f0173700a90bfafd64ab9f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#afe815086e4f0173700a90bfafd64ab9f">reset_marked_text</a> ()</td></tr>
<tr class="memdesc:afe815086e4f0173700a90bfafd64ab9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets marked text.  <a href="#afe815086e4f0173700a90bfafd64ab9f">More...</a><br /></td></tr>
<tr class="separator:afe815086e4f0173700a90bfafd64ab9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3b1236b41800d24267288c564b187a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a7a3b1236b41800d24267288c564b187a">run</a> ()</td></tr>
<tr class="memdesc:a7a3b1236b41800d24267288c564b187a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a>repeatedly as long as any windows are displayed.  <a href="#a7a3b1236b41800d24267288c564b187a">More...</a><br /></td></tr>
<tr class="separator:a7a3b1236b41800d24267288c564b187a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f806b9022d9ce5a062db83913e8475"><td class="memItemLeft" align="right" valign="top"><a id="a28f806b9022d9ce5a062db83913e8475"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>run_checks</b> ()</td></tr>
<tr class="separator:a28f806b9022d9ce5a062db83913e8475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d070bb1d5a24c28beab53a70af095a4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a9d070bb1d5a24c28beab53a70af095a4">scheme</a> (const char *name)</td></tr>
<tr class="memdesc:a9d070bb1d5a24c28beab53a70af095a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current widget scheme.  <a href="#a9d070bb1d5a24c28beab53a70af095a4">More...</a><br /></td></tr>
<tr class="separator:a9d070bb1d5a24c28beab53a70af095a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e0d5ea99335d7e4cdcf45d8dbe68b7"><td class="memItemLeft" align="right" valign="top"><a id="a48e0d5ea99335d7e4cdcf45d8dbe68b7"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a48e0d5ea99335d7e4cdcf45d8dbe68b7">scheme</a> ()</td></tr>
<tr class="memdesc:a48e0d5ea99335d7e4cdcf45d8dbe68b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See void <a class="el" href="classFl.html#a9d070bb1d5a24c28beab53a70af095a4" title="Sets the current widget scheme. ">scheme(const char *name)</a> <br /></td></tr>
<tr class="separator:a48e0d5ea99335d7e4cdcf45d8dbe68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa65116ad458fcb4a71c2f374de5dcd9"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gaaa65116ad458fcb4a71c2f374de5dcd9">screen_count</a> ()</td></tr>
<tr class="memdesc:gaaa65116ad458fcb4a71c2f374de5dcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of available screens. <br /></td></tr>
<tr class="separator:gaaa65116ad458fcb4a71c2f374de5dcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2c5b6e73b53eb3d99ae34cd35c07cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga1a2c5b6e73b53eb3d99ae34cd35c07cd">screen_dpi</a> (float &amp;<a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a>, float &amp;v, int n=0)</td></tr>
<tr class="memdesc:ga1a2c5b6e73b53eb3d99ae34cd35c07cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen resolution in dots-per-inch for the given screen.  <a href="group__fl__screen.html#ga1a2c5b6e73b53eb3d99ae34cd35c07cd">More...</a><br /></td></tr>
<tr class="separator:ga1a2c5b6e73b53eb3d99ae34cd35c07cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f50cdc3a9b33837434f01ee4742dc37"><td class="memItemLeft" align="right" valign="top"><a id="a5f50cdc3a9b33837434f01ee4742dc37"></a>
static Fl_Screen_Driver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a5f50cdc3a9b33837434f01ee4742dc37">screen_driver</a> ()</td></tr>
<tr class="memdesc:a5f50cdc3a9b33837434f01ee4742dc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the unique Fl_Screen_Driver object of the platform. <br /></td></tr>
<tr class="separator:a5f50cdc3a9b33837434f01ee4742dc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4ac46378ac0ed7e8b01927f88f3e8b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga2a4ac46378ac0ed7e8b01927f88f3e8b">screen_num</a> (int <a class="el" href="group__fl__screen.html#gaed836eacded3467aa838d02a1c55e3ab">x</a>, int <a class="el" href="group__fl__screen.html#gafa36572c1f755f8a9783efc351f19021">y</a>)</td></tr>
<tr class="memdesc:ga2a4ac46378ac0ed7e8b01927f88f3e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen number of a screen that contains the specified screen position <code>x</code>, <code>y</code>.  <a href="group__fl__screen.html#ga2a4ac46378ac0ed7e8b01927f88f3e8b">More...</a><br /></td></tr>
<tr class="separator:ga2a4ac46378ac0ed7e8b01927f88f3e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17da7e7c9cd5f8bb44e352910ce6cee8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga17da7e7c9cd5f8bb44e352910ce6cee8">screen_num</a> (int <a class="el" href="group__fl__screen.html#gaed836eacded3467aa838d02a1c55e3ab">x</a>, int <a class="el" href="group__fl__screen.html#gafa36572c1f755f8a9783efc351f19021">y</a>, int <a class="el" href="group__fl__screen.html#ga7aba4252407f539aa6d821551aaba5ff">w</a>, int <a class="el" href="group__fl__screen.html#ga7f42d75cf9b3e79bbe39e1041a657cdf">h</a>)</td></tr>
<tr class="memdesc:ga17da7e7c9cd5f8bb44e352910ce6cee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen number for the screen which intersects the most with the rectangle defined by <code>x</code>, <code>y</code>, <code>w</code>, <code>h</code>.  <a href="group__fl__screen.html#ga17da7e7c9cd5f8bb44e352910ce6cee8">More...</a><br /></td></tr>
<tr class="separator:ga17da7e7c9cd5f8bb44e352910ce6cee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1f3def038ace55315391d484be2d294"><td class="memItemLeft" align="right" valign="top">
static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gab1f3def038ace55315391d484be2d294">screen_scale</a> (int n)</td></tr>
<tr class="memdesc:gab1f3def038ace55315391d484be2d294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current value of the GUI scaling factor for screen number <code>n</code>. <br /></td></tr>
<tr class="separator:gab1f3def038ace55315391d484be2d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce8513415bdba5bd2d2f7661b5bba5d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga0ce8513415bdba5bd2d2f7661b5bba5d">screen_scale</a> (int n, float factor)</td></tr>
<tr class="memdesc:ga0ce8513415bdba5bd2d2f7661b5bba5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the GUI scaling factor for screen number <code>n</code>.  <a href="group__fl__screen.html#ga0ce8513415bdba5bd2d2f7661b5bba5d">More...</a><br /></td></tr>
<tr class="separator:ga0ce8513415bdba5bd2d2f7661b5bba5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabccd28d2ac973e21c791f81851afa26f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gabccd28d2ac973e21c791f81851afa26f">screen_scaling_supported</a> ()</td></tr>
<tr class="memdesc:gabccd28d2ac973e21c791f81851afa26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if scaling factors are supported by this platform.  <a href="group__fl__screen.html#gabccd28d2ac973e21c791f81851afa26f">More...</a><br /></td></tr>
<tr class="separator:gabccd28d2ac973e21c791f81851afa26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc1a0cf192a9e4376932a595003a89e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga0dc1a0cf192a9e4376932a595003a89e">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my)</td></tr>
<tr class="memdesc:ga0dc1a0cf192a9e4376932a595003a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of a screen that contains the specified screen position <code>mx</code>, <code>my</code>.  <a href="group__fl__screen.html#ga0dc1a0cf192a9e4376932a595003a89e">More...</a><br /></td></tr>
<tr class="separator:ga0dc1a0cf192a9e4376932a595003a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6d4dd670d06cd76ed0f3891ae80219"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga1b6d4dd670d06cd76ed0f3891ae80219">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int n)</td></tr>
<tr class="memdesc:ga1b6d4dd670d06cd76ed0f3891ae80219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of the given screen.  <a href="group__fl__screen.html#ga1b6d4dd670d06cd76ed0f3891ae80219">More...</a><br /></td></tr>
<tr class="separator:ga1b6d4dd670d06cd76ed0f3891ae80219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6127cd66b198303f38d4b3adc93d1622"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga6127cd66b198303f38d4b3adc93d1622">screen_work_area</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H)</td></tr>
<tr class="memdesc:ga6127cd66b198303f38d4b3adc93d1622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of the work area of the screen that contains the mouse pointer.  <a href="group__fl__screen.html#ga6127cd66b198303f38d4b3adc93d1622">More...</a><br /></td></tr>
<tr class="separator:ga6127cd66b198303f38d4b3adc93d1622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f151c6ebf206c46d2b9b03432d0e209"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga8f151c6ebf206c46d2b9b03432d0e209">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H)</td></tr>
<tr class="memdesc:ga8f151c6ebf206c46d2b9b03432d0e209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of a screen that contains the mouse pointer.  <a href="group__fl__screen.html#ga8f151c6ebf206c46d2b9b03432d0e209">More...</a><br /></td></tr>
<tr class="separator:ga8f151c6ebf206c46d2b9b03432d0e209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4caf50886ae88df6a957b8748ea113"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gaba4caf50886ae88df6a957b8748ea113">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my)</td></tr>
<tr class="memdesc:gaba4caf50886ae88df6a957b8748ea113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bounding box of a screen that contains the specified screen position <code>mx</code>, <code>my</code>.  <a href="group__fl__screen.html#gaba4caf50886ae88df6a957b8748ea113">More...</a><br /></td></tr>
<tr class="separator:gaba4caf50886ae88df6a957b8748ea113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52242843912b524e4a083e3272a2009"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gab52242843912b524e4a083e3272a2009">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int n)</td></tr>
<tr class="memdesc:gab52242843912b524e4a083e3272a2009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen bounding rect for the given screen.  <a href="group__fl__screen.html#gab52242843912b524e4a083e3272a2009">More...</a><br /></td></tr>
<tr class="separator:gab52242843912b524e4a083e3272a2009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe29a526a41ffb5df1c5116cf61ead54"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gabe29a526a41ffb5df1c5116cf61ead54">screen_xywh</a> (int &amp;X, int &amp;Y, int &amp;W, int &amp;H, int mx, int my, int mw, int mh)</td></tr>
<tr class="memdesc:gabe29a526a41ffb5df1c5116cf61ead54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the screen bounding rect for the screen which intersects the most with the rectangle defined by <code>mx</code>, <code>my</code>, <code>mw</code>, <code>mh</code>.  <a href="group__fl__screen.html#gabe29a526a41ffb5df1c5116cf61ead54">More...</a><br /></td></tr>
<tr class="separator:gabe29a526a41ffb5df1c5116cf61ead54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c225037f05d07a7797da5eddafb33a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a82c225037f05d07a7797da5eddafb33a">scrollbar_size</a> ()</td></tr>
<tr class="memdesc:a82c225037f05d07a7797da5eddafb33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default scrollbar size used by <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers. ">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text. ">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window...">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget. ">Fl_Text_Display</a> widgets.  <a href="#a82c225037f05d07a7797da5eddafb33a">More...</a><br /></td></tr>
<tr class="separator:a82c225037f05d07a7797da5eddafb33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d2b6e0d640b81c6ec44d0164ec0f91"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#aa6d2b6e0d640b81c6ec44d0164ec0f91">scrollbar_size</a> (int W)</td></tr>
<tr class="memdesc:aa6d2b6e0d640b81c6ec44d0164ec0f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default scrollbar size that is used by the <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers. ">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text. ">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window...">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget. ">Fl_Text_Display</a> widgets.  <a href="#aa6d2b6e0d640b81c6ec44d0164ec0f91">More...</a><br /></td></tr>
<tr class="separator:aa6d2b6e0d640b81c6ec44d0164ec0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2993c9b0292c636357b1268fb63e827"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gac2993c9b0292c636357b1268fb63e827">selection</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> &amp;owner, const char *, int len)</td></tr>
<tr class="memdesc:gac2993c9b0292c636357b1268fb63e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current selection.  <a href="group__fl__clipboard.html#gac2993c9b0292c636357b1268fb63e827">More...</a><br /></td></tr>
<tr class="separator:gac2993c9b0292c636357b1268fb63e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab237801bd5deece817c5001e9a72fdef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classFl__Widget.html">Fl_Widget</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gab237801bd5deece817c5001e9a72fdef">selection_owner</a> ()</td></tr>
<tr class="memdesc:gab237801bd5deece817c5001e9a72fdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-compatibility only: Gets the widget owning the current selection  <a href="group__fl__clipboard.html#gab237801bd5deece817c5001e9a72fdef">More...</a><br /></td></tr>
<tr class="separator:gab237801bd5deece817c5001e9a72fdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec21e41f0909a27c9906e1a12aee319b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#gaec21e41f0909a27c9906e1a12aee319b">selection_owner</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *)</td></tr>
<tr class="memdesc:gaec21e41f0909a27c9906e1a12aee319b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-compatibility only: The single-argument call can be used to move the selection to another widget or to set the owner to NULL, without changing the actual text of the selection.  <a href="group__fl__clipboard.html#gaec21e41f0909a27c9906e1a12aee319b">More...</a><br /></td></tr>
<tr class="separator:gaec21e41f0909a27c9906e1a12aee319b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52e562142bd1e8d5ba6915ff5577245"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gaa52e562142bd1e8d5ba6915ff5577245">set_abort</a> (<a class="el" href="group__callback__functions.html#gab06d501e53b8fe82de6d70937fb22f95">Fl_Abort_Handler</a> f)</td></tr>
<tr class="memdesc:gaa52e562142bd1e8d5ba6915ff5577245"><td class="mdescLeft">&#160;</td><td class="mdescRight">For back compatibility, sets the void <a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a" title="FLTK calls Fl::fatal() to output a fatal error message. ">Fl::fatal</a> handler callback. <br /></td></tr>
<tr class="separator:gaa52e562142bd1e8d5ba6915ff5577245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2b995bdaf60c5a5b2326e8845897c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#gafe2b995bdaf60c5a5b2326e8845897c9">set_atclose</a> (<a class="el" href="group__callback__functions.html#gac2b36f6e136744adb3e3ec87e068c169">Fl_Atclose_Handler</a> f)</td></tr>
<tr class="memdesc:gafe2b995bdaf60c5a5b2326e8845897c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For back compatibility, sets the <a class="el" href="group__fl__windows.html#ga51afae3e9f75ffb9bbac49844195715c" title="Back compatibility: default window callback handler. ">Fl::atclose</a> handler callback.  <a href="group__fl__windows.html#gafe2b995bdaf60c5a5b2326e8845897c9">More...</a><br /></td></tr>
<tr class="separator:gafe2b995bdaf60c5a5b2326e8845897c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41fc4e972e6c2056529e0d393141147"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae41fc4e972e6c2056529e0d393141147">set_box_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>)</td></tr>
<tr class="memdesc:ae41fc4e972e6c2056529e0d393141147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the drawing color for the box that is currently drawn.  <a href="#ae41fc4e972e6c2056529e0d393141147">More...</a><br /></td></tr>
<tr class="separator:ae41fc4e972e6c2056529e0d393141147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e0e8fefe8707817ca6fd6437c4869b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a73e0e8fefe8707817ca6fd6437c4869b">set_boxtype</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>, <a class="el" href="group__callback__functions.html#gacb24a62f521a0e02cd7872a3bfbf3855">Fl_Box_Draw_F</a> *, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:a73e0e8fefe8707817ca6fd6437c4869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function to call to draw a specific boxtype.  <a href="#a73e0e8fefe8707817ca6fd6437c4869b">More...</a><br /></td></tr>
<tr class="separator:a73e0e8fefe8707817ca6fd6437c4869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337397ba0fb948633c83ad7c39a67e00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a337397ba0fb948633c83ad7c39a67e00">set_boxtype</a> (<a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>, <a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a> from)</td></tr>
<tr class="memdesc:a337397ba0fb948633c83ad7c39a67e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the from boxtype.  <a href="#a337397ba0fb948633c83ad7c39a67e00">More...</a><br /></td></tr>
<tr class="separator:a337397ba0fb948633c83ad7c39a67e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac62f634ba8089a9d0e48bf57154c61b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gac62f634ba8089a9d0e48bf57154c61b0">set_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>, <a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>)</td></tr>
<tr class="memdesc:gac62f634ba8089a9d0e48bf57154c61b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry in the fl_color index table.  <a href="group__fl__attributes.html#gac62f634ba8089a9d0e48bf57154c61b0">More...</a><br /></td></tr>
<tr class="separator:gac62f634ba8089a9d0e48bf57154c61b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a6050ee3979754023eb1e66976240d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gaa6a6050ee3979754023eb1e66976240d">set_color</a> (<a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> i, unsigned c)</td></tr>
<tr class="memdesc:gaa6a6050ee3979754023eb1e66976240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an entry in the fl_color index table.  <a href="group__fl__attributes.html#gaa6a6050ee3979754023eb1e66976240d">More...</a><br /></td></tr>
<tr class="separator:gaa6a6050ee3979754023eb1e66976240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15dee80a622a9ab2798acfdc0aabcd95"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#ga15dee80a622a9ab2798acfdc0aabcd95">set_font</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, const char *)</td></tr>
<tr class="memdesc:ga15dee80a622a9ab2798acfdc0aabcd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a face.  <a href="group__fl__attributes.html#ga15dee80a622a9ab2798acfdc0aabcd95">More...</a><br /></td></tr>
<tr class="separator:ga15dee80a622a9ab2798acfdc0aabcd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace5762f829e283f7965eca8d70042a32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gace5762f829e283f7965eca8d70042a32">set_font</a> (<a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>, <a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>)</td></tr>
<tr class="memdesc:gace5762f829e283f7965eca8d70042a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one face to another.  <a href="group__fl__attributes.html#gace5762f829e283f7965eca8d70042a32">More...</a><br /></td></tr>
<tr class="separator:gace5762f829e283f7965eca8d70042a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa546e0caa16420399c3202fd75efd4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="Enumerations_8H.html#a2ac46d9f082834b969fffe490a03a709">Fl_Font</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__attributes.html#gadfa546e0caa16420399c3202fd75efd4">set_fonts</a> (const char *=0)</td></tr>
<tr class="memdesc:gadfa546e0caa16420399c3202fd75efd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK will open the display, and add every fonts on the server to the face table.  <a href="group__fl__attributes.html#gadfa546e0caa16420399c3202fd75efd4">More...</a><br /></td></tr>
<tr class="separator:gadfa546e0caa16420399c3202fd75efd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77955ad2f2b83fc5e3925b94e4533b20"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a77955ad2f2b83fc5e3925b94e4533b20">set_idle</a> (<a class="el" href="group__callback__functions.html#ga238786923bf2e91732a7305fc0647dbf">Fl_Old_Idle_Handler</a> cb)</td></tr>
<tr class="memdesc:a77955ad2f2b83fc5e3925b94e4533b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an idle callback.  <a href="#a77955ad2f2b83fc5e3925b94e4533b20">More...</a><br /></td></tr>
<tr class="separator:a77955ad2f2b83fc5e3925b94e4533b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2041799ff3f57f4cced52d7e3b3a544a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a2041799ff3f57f4cced52d7e3b3a544a">set_labeltype</a> (<a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>, <a class="el" href="group__callback__functions.html#ga569530b250a4e2f56022249512687a0c">Fl_Label_Draw_F</a> *, <a class="el" href="group__callback__functions.html#ga946140c0dcd42dbef9f134af6f2da17b">Fl_Label_Measure_F</a> *)</td></tr>
<tr class="memdesc:a2041799ff3f57f4cced52d7e3b3a544a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the functions to call to draw and measure a specific labeltype.  <a href="#a2041799ff3f57f4cced52d7e3b3a544a">More...</a><br /></td></tr>
<tr class="separator:a2041799ff3f57f4cced52d7e3b3a544a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1633da3e36598ebe875f0c16fc9f198"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad1633da3e36598ebe875f0c16fc9f198">set_labeltype</a> (<a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>, <a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a> from)</td></tr>
<tr class="memdesc:ad1633da3e36598ebe875f0c16fc9f198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the functions to call to draw and measure a specific labeltype.  <a href="#ad1633da3e36598ebe875f0c16fc9f198">More...</a><br /></td></tr>
<tr class="separator:ad1633da3e36598ebe875f0c16fc9f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808d0335818b286be9101588a36619d2"><td class="memItemLeft" align="right" valign="top"><a id="a808d0335818b286be9101588a36619d2"></a>
static Fl_System_Driver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a808d0335818b286be9101588a36619d2">system_driver</a> ()</td></tr>
<tr class="memdesc:a808d0335818b286be9101588a36619d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the unique Fl_System_Driver object of the platform. <br /></td></tr>
<tr class="separator:a808d0335818b286be9101588a36619d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b767183ac691d4249f599b94dafe78"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__events.html#gab8b767183ac691d4249f599b94dafe78">test_shortcut</a> (<a class="el" href="fl__types_8h.html#a37ec1cd050a604a45dff00efba45609d">Fl_Shortcut</a>)</td></tr>
<tr class="memdesc:gab8b767183ac691d4249f599b94dafe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the current event, which must be an FL_KEYBOARD or FL_SHORTCUT, against a shortcut value (described in <a class="el" href="classFl__Button.html" title="Buttons generate callbacks when they are clicked by the user. ">Fl_Button</a>).  <a href="group__fl__events.html#gab8b767183ac691d4249f599b94dafe78">More...</a><br /></td></tr>
<tr class="separator:gab8b767183ac691d4249f599b94dafe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82258694ec1baf11c3756c965b2c501e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e">thread_message</a> ()</td></tr>
<tr class="memdesc:ga82258694ec1baf11c3756c965b2c501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e" title="The thread_message() method returns the last message that was sent from a child by the awake() method...">thread_message()</a> method returns the last message that was sent from a child by the <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a> method.  <a href="group__fl__multithread.html#ga82258694ec1baf11c3756c965b2c501e">More...</a><br /></td></tr>
<tr class="separator:ga82258694ec1baf11c3756c965b2c501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9375cc078d9d39161e2cba520829fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd">unlock</a> ()</td></tr>
<tr class="memdesc:ga2b9375cc078d9d39161e2cba520829fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd" title="The unlock() method releases the lock that was set using the lock() method. ">unlock()</a> method releases the lock that was set using the <a class="el" href="group__fl__multithread.html#gaf6f46de66cc183bc5b38cd364aca4cf2" title="The lock() method blocks the current thread until it can safely access FLTK widgets and data...">lock()</a> method.  <a href="group__fl__multithread.html#ga2b9375cc078d9d39161e2cba520829fd">More...</a><br /></td></tr>
<tr class="separator:ga2b9375cc078d9d39161e2cba520829fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f52e1de14ecab5166a921640fbee640"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a3f52e1de14ecab5166a921640fbee640">use_high_res_GL</a> (int val)</td></tr>
<tr class="memdesc:a3f52e1de14ecab5166a921640fbee640"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets whether GL windows should be drawn at high resolution on Apple computers with retina displays  <a href="#a3f52e1de14ecab5166a921640fbee640">More...</a><br /></td></tr>
<tr class="separator:a3f52e1de14ecab5166a921640fbee640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841e929912f3604e0a3d0ef1dff245c8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a841e929912f3604e0a3d0ef1dff245c8">use_high_res_GL</a> ()</td></tr>
<tr class="memdesc:a841e929912f3604e0a3d0ef1dff245c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether GL windows should be drawn at high resolution on Apple computers with retina displays.  <a href="#a841e929912f3604e0a3d0ef1dff245c8">More...</a><br /></td></tr>
<tr class="separator:a841e929912f3604e0a3d0ef1dff245c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65803adc5e4936111bd31a52f1d61a7"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ad65803adc5e4936111bd31a52f1d61a7">version</a> ()</td></tr>
<tr class="memdesc:ad65803adc5e4936111bd31a52f1d61a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compiled-in value of the FL_VERSION constant.  <a href="#ad65803adc5e4936111bd31a52f1d61a7">More...</a><br /></td></tr>
<tr class="separator:ad65803adc5e4936111bd31a52f1d61a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5fd097d36257dce2b7aff1165e037f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ade5fd097d36257dce2b7aff1165e037f">visible_focus</a> (int v)</td></tr>
<tr class="memdesc:ade5fd097d36257dce2b7aff1165e037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the visible keyboard focus on buttons and other non-text widgets.  <a href="#ade5fd097d36257dce2b7aff1165e037f">More...</a><br /></td></tr>
<tr class="separator:ade5fd097d36257dce2b7aff1165e037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9eaddd02a0aa637078ee2dd80b85b2f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#ae9eaddd02a0aa637078ee2dd80b85b2f">visible_focus</a> ()</td></tr>
<tr class="memdesc:ae9eaddd02a0aa637078ee2dd80b85b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or sets the visible keyboard focus on buttons and other non-text widgets.  <a href="#ae9eaddd02a0aa637078ee2dd80b85b2f">More...</a><br /></td></tr>
<tr class="separator:ae9eaddd02a0aa637078ee2dd80b85b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6deb3d4f76b538d508b36700dfb6b0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0">visual</a> (int)</td></tr>
<tr class="memdesc:a6d6deb3d4f76b538d508b36700dfb6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects a visual so that your graphics are drawn correctly.  <a href="#a6d6deb3d4f76b538d508b36700dfb6b0">More...</a><br /></td></tr>
<tr class="separator:a6d6deb3d4f76b538d508b36700dfb6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aba4252407f539aa6d821551aaba5ff"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#ga7aba4252407f539aa6d821551aaba5ff">w</a> ()</td></tr>
<tr class="memdesc:ga7aba4252407f539aa6d821551aaba5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width in pixels of the main screen work area.  <a href="group__fl__screen.html#ga7aba4252407f539aa6d821551aaba5ff">More...</a><br /></td></tr>
<tr class="separator:ga7aba4252407f539aa6d821551aaba5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108a84216f0b3fa1cb0c46ab7449a312"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312">wait</a> ()</td></tr>
<tr class="memdesc:a108a84216f0b3fa1cb0c46ab7449a312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until "something happens" and then returns.  <a href="#a108a84216f0b3fa1cb0c46ab7449a312">More...</a><br /></td></tr>
<tr class="separator:a108a84216f0b3fa1cb0c46ab7449a312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49654e35a0b636aa751dce5ff88a7f5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#af49654e35a0b636aa751dce5ff88a7f5">wait</a> (double time)</td></tr>
<tr class="memdesc:af49654e35a0b636aa751dce5ff88a7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits a maximum of <code>time_to_wait</code> seconds or until "something happens".  <a href="#af49654e35a0b636aa751dce5ff88a7f5">More...</a><br /></td></tr>
<tr class="separator:af49654e35a0b636aa751dce5ff88a7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ecd6d20b793fd0f3081eaab369caa9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9">watch_widget_pointer</a> (<a class="el" href="classFl__Widget.html">Fl_Widget</a> *&amp;<a class="el" href="group__fl__screen.html#ga7aba4252407f539aa6d821551aaba5ff">w</a>)</td></tr>
<tr class="memdesc:ga16ecd6d20b793fd0f3081eaab369caa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a widget pointer to the widget watch list.  <a href="group__fl__del__widget.html#ga16ecd6d20b793fd0f3081eaab369caa9">More...</a><br /></td></tr>
<tr class="separator:ga16ecd6d20b793fd0f3081eaab369caa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed836eacded3467aa838d02a1c55e3ab"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gaed836eacded3467aa838d02a1c55e3ab">x</a> ()</td></tr>
<tr class="memdesc:gaed836eacded3467aa838d02a1c55e3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the leftmost x coordinate of the main screen work area.  <a href="group__fl__screen.html#gaed836eacded3467aa838d02a1c55e3ab">More...</a><br /></td></tr>
<tr class="separator:gaed836eacded3467aa838d02a1c55e3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa36572c1f755f8a9783efc351f19021"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__screen.html#gafa36572c1f755f8a9783efc351f19021">y</a> ()</td></tr>
<tr class="memdesc:gafa36572c1f755f8a9783efc351f19021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the topmost y coordinate of the main screen work area.  <a href="group__fl__screen.html#gafa36572c1f755f8a9783efc351f19021">More...</a><br /></td></tr>
<tr class="separator:gafa36572c1f755f8a9783efc351f19021"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ga51afae3e9f75ffb9bbac49844195715c"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__windows.html#ga51afae3e9f75ffb9bbac49844195715c">atclose</a> )(<a class="el" href="classFl__Window.html">Fl_Window</a> *, void *)</td></tr>
<tr class="memdesc:ga51afae3e9f75ffb9bbac49844195715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back compatibility: default window callback handler.  <a href="group__fl__windows.html#ga51afae3e9f75ffb9bbac49844195715c">More...</a><br /></td></tr>
<tr class="separator:ga51afae3e9f75ffb9bbac49844195715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ed7d2c724b25185ba6f4d7778d14dca"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__gfx.html#ga0ed7d2c724b25185ba6f4d7778d14dca">cfg_gfx_cairo</a> = 0</td></tr>
<tr class="memdesc:ga0ed7d2c724b25185ba6f4d7778d14dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cairo rendering available, available on many platforms. <br /></td></tr>
<tr class="separator:ga0ed7d2c724b25185ba6f4d7778d14dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219d124d0b0cbc9cc16ada9e7a82788d"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__gfx.html#ga219d124d0b0cbc9cc16ada9e7a82788d">cfg_gfx_directx</a> = 0</td></tr>
<tr class="memdesc:ga219d124d0b0cbc9cc16ada9e7a82788d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DirectX rendering available, usually on Windows systems. <br /></td></tr>
<tr class="separator:ga219d124d0b0cbc9cc16ada9e7a82788d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga783a6cedd03ac646e5621b0384d184e6"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__gfx.html#ga783a6cedd03ac646e5621b0384d184e6">cfg_gfx_gdi</a> = 0</td></tr>
<tr class="memdesc:ga783a6cedd03ac646e5621b0384d184e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">GDI rendering available, usually on Windows systems. <br /></td></tr>
<tr class="separator:ga783a6cedd03ac646e5621b0384d184e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ce383c63a8692cd7649c9807aff576"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__gfx.html#gab1ce383c63a8692cd7649c9807aff576">cfg_gfx_opengl</a> = 0</td></tr>
<tr class="memdesc:gab1ce383c63a8692cd7649c9807aff576"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL rendering available, available on many platforms. <br /></td></tr>
<tr class="separator:gab1ce383c63a8692cd7649c9807aff576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec13035cd66c45cdc3df5fd89d1dba72"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__gfx.html#gaec13035cd66c45cdc3df5fd89d1dba72">cfg_gfx_quartz</a> = 0</td></tr>
<tr class="memdesc:gaec13035cd66c45cdc3df5fd89d1dba72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quartz rendering available, usually on OS X systems. <br /></td></tr>
<tr class="separator:gaec13035cd66c45cdc3df5fd89d1dba72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3283f8dc0e6d563b6026007c70be831b"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__gfx.html#ga3283f8dc0e6d563b6026007c70be831b">cfg_gfx_xlib</a> = 0</td></tr>
<tr class="memdesc:ga3283f8dc0e6d563b6026007c70be831b"><td class="mdescLeft">&#160;</td><td class="mdescRight">X11 Xlib rendering available, usually on Linux systems. <br /></td></tr>
<tr class="separator:ga3283f8dc0e6d563b6026007c70be831b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8a22b2b2269588a80fe0471e989ef1"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__prn.html#ga8b8a22b2b2269588a80fe0471e989ef1">cfg_prn_gdi</a> = 0</td></tr>
<tr class="memdesc:ga8b8a22b2b2269588a80fe0471e989ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">GDI rendering available, usually on Windows systems. <br /></td></tr>
<tr class="separator:ga8b8a22b2b2269588a80fe0471e989ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5fef57e792391531c87e3dc360d25d7"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__prn.html#gaf5fef57e792391531c87e3dc360d25d7">cfg_prn_ps</a> = 0</td></tr>
<tr class="memdesc:gaf5fef57e792391531c87e3dc360d25d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PostScript rendering available, usually on Linux systems. <br /></td></tr>
<tr class="separator:gaf5fef57e792391531c87e3dc360d25d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba81c5ab36ea681a50f107154e714013"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__prn.html#gaba81c5ab36ea681a50f107154e714013">cfg_prn_quartz</a> = 0</td></tr>
<tr class="memdesc:gaba81c5ab36ea681a50f107154e714013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quartz rendering available, usually on OS X systems. <br /></td></tr>
<tr class="separator:gaba81c5ab36ea681a50f107154e714013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a29e035f3c9e69e0eda186aa654a644"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__sys.html#ga3a29e035f3c9e69e0eda186aa654a644">cfg_sys_posix</a> = 0</td></tr>
<tr class="memdesc:ga3a29e035f3c9e69e0eda186aa654a644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posix system available, usually on Linux and OS X systems, but also Cygwin. <br /></td></tr>
<tr class="separator:ga3a29e035f3c9e69e0eda186aa654a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727d603e9eeb10e752dded6e8a193ed8"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__sys.html#ga727d603e9eeb10e752dded6e8a193ed8">cfg_sys_win32</a> = 0</td></tr>
<tr class="memdesc:ga727d603e9eeb10e752dded6e8a193ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Windows system available, on Windows. <br /></td></tr>
<tr class="separator:ga727d603e9eeb10e752dded6e8a193ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795d2b8b53d7e7763506d07f50eb1675"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__win.html#ga795d2b8b53d7e7763506d07f50eb1675">cfg_win_cocoa</a> = 0</td></tr>
<tr class="memdesc:ga795d2b8b53d7e7763506d07f50eb1675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cocoa window management available, usually on OS X systems. <br /></td></tr>
<tr class="separator:ga795d2b8b53d7e7763506d07f50eb1675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46538c6dd8beaabf2d286f24d7b8f1e5"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__win.html#ga46538c6dd8beaabf2d286f24d7b8f1e5">cfg_win_win32</a> = 0</td></tr>
<tr class="memdesc:ga46538c6dd8beaabf2d286f24d7b8f1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Windows window management available, on low level Windows. <br /></td></tr>
<tr class="separator:ga46538c6dd8beaabf2d286f24d7b8f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea8b3e8df602ec95bb0688ddcd22a21"><td class="memItemLeft" align="right" valign="top">
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cfg__win.html#gaeea8b3e8df602ec95bb0688ddcd22a21">cfg_win_x11</a> = 0</td></tr>
<tr class="memdesc:gaeea8b3e8df602ec95bb0688ddcd22a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">X11 window management available, usually on Linux systems. <br /></td></tr>
<tr class="separator:gaeea8b3e8df602ec95bb0688ddcd22a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1a7a0f0cd1fa222b6042f7dce4b65d"><td class="memItemLeft" align="right" valign="top">
static char const  *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga2f1a7a0f0cd1fa222b6042f7dce4b65d">clipboard_image</a> = &quot;image&quot;</td></tr>
<tr class="memdesc:ga2f1a7a0f0cd1fa222b6042f7dce4b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes image data. <br /></td></tr>
<tr class="separator:ga2f1a7a0f0cd1fa222b6042f7dce4b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96135e2dd04bfd737085ef5fb3d824e1"><td class="memItemLeft" align="right" valign="top">
static char const  *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__clipboard.html#ga96135e2dd04bfd737085ef5fb3d824e1">clipboard_plain_text</a> = &quot;text/plain&quot;</td></tr>
<tr class="memdesc:ga96135e2dd04bfd737085ef5fb3d824e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes plain textual data. <br /></td></tr>
<tr class="separator:ga96135e2dd04bfd737085ef5fb3d824e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga163461446c664de8d1785ee0e4515f23"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23">error</a> )(const char *,...) = Fl_System_Driver::error</td></tr>
<tr class="memdesc:ga163461446c664de8d1785ee0e4515f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23" title="FLTK calls Fl::error() to output a normal error message. ">Fl::error()</a> to output a normal error message.  <a href="group__group__comdlg.html#ga163461446c664de8d1785ee0e4515f23">More...</a><br /></td></tr>
<tr class="separator:ga163461446c664de8d1785ee0e4515f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181c7012ef5dd3a551a4e861c9fc974a"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a">fatal</a> )(const char *,...) = Fl_System_Driver::fatal</td></tr>
<tr class="memdesc:ga181c7012ef5dd3a551a4e861c9fc974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a" title="FLTK calls Fl::fatal() to output a fatal error message. ">Fl::fatal()</a> to output a fatal error message.  <a href="group__group__comdlg.html#ga181c7012ef5dd3a551a4e861c9fc974a">More...</a><br /></td></tr>
<tr class="separator:ga181c7012ef5dd3a551a4e861c9fc974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d41edd7d962116d86a9db810210f7b"><td class="memItemLeft" align="right" valign="top">static const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a64d41edd7d962116d86a9db810210f7b">help</a> = helpmsg+13</td></tr>
<tr class="memdesc:a64d41edd7d962116d86a9db810210f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usage string displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler. ">Fl::args()</a> detects an invalid argument.  <a href="#a64d41edd7d962116d86a9db810210f7b">More...</a><br /></td></tr>
<tr class="separator:a64d41edd7d962116d86a9db810210f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fb2b446096dd4742511edb459653d3"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFl.html#a60fb2b446096dd4742511edb459653d3">idle</a> )()</td></tr>
<tr class="memdesc:a60fb2b446096dd4742511edb459653d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently executing idle callback function: DO NOT USE THIS DIRECTLY!  <a href="#a60fb2b446096dd4742511edb459653d3">More...</a><br /></td></tr>
<tr class="separator:a60fb2b446096dd4742511edb459653d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec4624fcfc09e75fdaf59c2553fe8a9"><td class="memItemLeft" align="right" valign="top">static void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9">warning</a> )(const char *,...) = Fl_System_Driver::warning</td></tr>
<tr class="memdesc:gadec4624fcfc09e75fdaf59c2553fe8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLTK calls <a class="el" href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9" title="FLTK calls Fl::warning() to output a warning message. ">Fl::warning()</a> to output a warning message.  <a href="group__group__comdlg.html#gadec4624fcfc09e75fdaf59c2553fe8a9">More...</a><br /></td></tr>
<tr class="separator:gadec4624fcfc09e75fdaf59c2553fe8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classFl.html" title="The Fl is the FLTK global (static) class containing state information and global methods for the curr...">Fl</a> is the FLTK global (static) class containing state information and global methods for the current application. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a43e6e0bbbc03cad134d928d4edd48d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e6e0bbbc03cad134d928d4edd48d1d">&#9670;&nbsp;</a></span>Fl_Option</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl::Fl_Option</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerator for global FLTK options. </p>
<p>These options can be set system wide, per user, or for the running application only. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16" title="Override an option while the application is running. ">Fl::option(Fl_Option, bool)</a> </dd>
<dd>
<a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management. ">Fl::option(Fl_Option)</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6"></a>OPTION_ARROW_FOCUS&#160;</td><td class="fielddoc"><p>When switched on, moving the text cursor beyond the start or end of a text in a text widget will change focus to the next text widget. </p>
<p>(This is considered 'old' behavior)</p>
<p>When switched off (default), the cursor will stop at the end of the text. Pressing Tab or Ctrl-Tab will advance the keyboard focus.</p>
<p>See also: <a class="el" href="classFl__Input__.html#ae23c19c0081ab427fc5ad53d4f503f8d" title="Sets whether the Tab key does focus navigation, or inserts tab characters into Fl_Multiline_Input. ">Fl_Input_::tab_nav()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1dade29f22fc8066222d99ea3ccebc5e655"></a>OPTION_VISIBLE_FOCUS&#160;</td><td class="fielddoc"><p>If visible focus is switched on (default), FLTK will draw a dotted rectangle inside the widget that will receive the next keystroke. </p>
<p>If switched off, no such indicator will be drawn and keyboard navigation is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da2344bf14f80ecf5971e8aa4493a3858a"></a>OPTION_DND_TEXT&#160;</td><td class="fielddoc"><p>If text drag-and-drop is enabled (default), the user can select and drag text from any text widget. </p>
<p>If disabled, no dragging is possible, however dropping text from other applications still works. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1dae8214e42f77fe157297d61fdb818be2f"></a>OPTION_SHOW_TOOLTIPS&#160;</td><td class="fielddoc"><p>If tooltips are enabled (default), hovering the mouse over a widget with a tooltip text will open a little tooltip window until the mouse leaves the widget. </p>
<p>If disabled, no tooltip is shown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da01d530d6bc747eb0c192038eb802a8bd"></a>OPTION_FNFC_USES_GTK&#160;</td><td class="fielddoc"><p>When switched on (default), <a class="el" href="classFl__Native__File__Chooser.html" title="This class lets an FLTK application easily and consistently access the operating system&#39;s native file...">Fl_Native_File_Chooser</a> runs GTK file dialogs if the GTK library is available on the platform (linux/unix only). </p>
<p>When switched off, GTK file dialogs aren't used even if the GTK library is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da5afc672e2e7e8f31ea9583b6c9ec6120"></a>OPTION_PRINTER_USES_GTK&#160;</td><td class="fielddoc"><p>When switched on (default), <a class="el" href="classFl__Printer.html" title="OS-independent print support. ">Fl_Printer</a> runs the GTK printer dialog if the GTK library is available on the platform (linux/unix only). </p>
<p>When switched off, the GTK printer dialog isn't used even if the GTK library is available. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1dacf161d7667d109842094b2f2a08f0f3c"></a>OPTION_SHOW_SCALING&#160;</td><td class="fielddoc"><p>When switched on (default), the library shows in a transient yellow window the zoom factor value. </p>
<p>When switched off, no such window gets displayed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43e6e0bbbc03cad134d928d4edd48d1da220ebf62255fc47e5b5f213b410e2bc5"></a>OPTION_LAST&#160;</td><td class="fielddoc"><p>For internal use only. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeec1fc58b2ded93866e75fc0f317b284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec1fc58b2ded93866e75fc0f317b284">&#9670;&nbsp;</a></span>abi_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::abi_check </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>val</em> = <code><a class="el" href="Enumerations_8H.html#a619cd27e13a15a7b1b5ead0932dd3912">FL_ABI_VERSION</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the runtime library ABI version is correct. </p>
<p>This enables you to check the ABI version of the linked FLTK library at runtime.</p>
<p>Returns 1 (true) if the compiled ABI version (in the header files) and the linked library ABI version (used at runtime) are the same, 0 (false) otherwise.</p>
<p>Argument <code>val</code> can be used to query a particular library ABI version. Use for instance 10303 to query if the runtime library is compatible with FLTK ABI version 1.3.3. This is rarely useful.</p>
<p>The default <code>val</code> argument is FL_ABI_VERSION, which checks the version defined at configure time (i.e. in the header files at program compilation time) against the linked library version used at runtime. This is particularly useful if you linked with a shared object library, but it also concerns static linking.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#aaa664880d0a1fab25b7bb53803112093" title="Returns the compiled-in value of the FL_ABI_VERSION constant. ">Fl::abi_version()</a> </dd></dl>

</div>
</div>
<a id="aaa664880d0a1fab25b7bb53803112093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa664880d0a1fab25b7bb53803112093">&#9670;&nbsp;</a></span>abi_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::abi_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the compiled-in value of the FL_ABI_VERSION constant. </p>
<p>This is useful for checking the version of a shared library. </p>

</div>
</div>
<a id="afff1ee2c6afa6463293a2188a44b00b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff1ee2c6afa6463293a2188a44b00b5">&#9670;&nbsp;</a></span>add_awake_handler_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::add_awake_handler_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>. </p>

</div>
</div>
<a id="a7b689a9e42582fe6e87f7c7eb1dce94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b689a9e42582fe6e87f7c7eb1dce94f">&#9670;&nbsp;</a></span>add_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FLTK will call this callback just before it flushes the display and waits for events. </p>
<p>This is different than an idle callback because it is only called once, then FLTK calls the system and tells it not to return until an event happens.</p>
<p>This can be used by code that wants to monitor the application's state, such as to keep a display up to date. The advantage of using a check callback is that it is called only when no events are pending. If events are coming in quickly, whole blocks of them will be processed before this is called once. This can save significant time and avoid the application falling behind the events.</p>
<p>Sample code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> state_changed; <span class="comment">// anything that changes the display turns this on</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {</div><div class="line"> <span class="keywordflow">if</span> (!state_changed) <span class="keywordflow">return</span>;</div><div class="line"> state_changed = <span class="keyword">false</span>;</div><div class="line"> do_expensive_calculation();</div><div class="line"> widget-&amp;gt;<a class="code" href="classFl.html#aeec5e7939d214882da2d31c894a5bad7">redraw</a>();</div><div class="line">}</div><div class="line"></div><div class="line">main() {</div><div class="line"> <a class="code" href="classFl.html#a7b689a9e42582fe6e87f7c7eb1dce94f">Fl::add_check</a>(callback);</div><div class="line"> <span class="keywordflow">return</span> <a class="code" href="classFl.html#a7a3b1236b41800d24267288c564b187a">Fl::run</a>();</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a8905e303e45e846b8ce77168f4cf7afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8905e303e45e846b8ce77168f4cf7afe">&#9670;&nbsp;</a></span>add_fd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga2cff1a51089da7653ab49bae499dfbf4">Fl_FD_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds file descriptor fd to listen to. </p>
<p>When the fd becomes ready for reading <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> will call the callback and then return. The callback is passed the fd and the arbitrary void* argument.</p>
<p>This version takes a when bitfield, with the bits FL_READ, FL_WRITE, and FL_EXCEPT defined, to indicate when the callback should be done.</p>
<p>There can only be one callback of each type for a file descriptor. <a class="el" href="classFl.html#a71e75c1a559e3415c5304c37235af831" title="Removes a file descriptor handler. ">Fl::remove_fd()</a> gets rid of <em>all</em> the callbacks for a given file descriptor.</p>
<p>Under UNIX/Linux/MacOS <em>any</em> file descriptor can be monitored (files, devices, pipes, sockets, etc.). Due to limitations in Microsoft Windows, Windows applications can only monitor sockets. </p>

</div>
</div>
<a id="a7e5e7aac775b05f0c985bb352f5add24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5e7aac775b05f0c985bb352f5add24">&#9670;&nbsp;</a></span>add_fd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga2cff1a51089da7653ab49bae499dfbf4">Fl_FD_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds file descriptor fd to listen to. </p>
<p>See <a class="el" href="classFl.html#a8905e303e45e846b8ce77168f4cf7afe" title="Adds file descriptor fd to listen to. ">Fl::add_fd</a>(int fd, int when, Fl_FD_Handler cb, void* = 0) for details </p>

</div>
</div>
<a id="a4e7a1b5d18c2f073238a8466a62a3e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7a1b5d18c2f073238a8466a62a3e7a">&#9670;&nbsp;</a></span>add_idle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gac9d2aab1d3142308450e2da09716013e">Fl_Idle_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback function that is called every time by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> and also makes it act as though the timeout is zero (this makes <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> return immediately, so if it is in a loop it is called repeatedly, and thus the idle fucntion is called repeatedly). </p>
<p>The idle function can be used to get background processing done.</p>
<p>You can have multiple idle callbacks. To remove an idle callback use <a class="el" href="classFl.html#a43903f998a07e1cca7ba199c8ed25d9b" title="Removes the specified idle callback, if it is installed. ">Fl::remove_idle()</a>.</p>
<p><a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> and <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0). ">Fl::check()</a> call idle callbacks, but <a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f" title="This is similar to Fl::check() except this does not call Fl::flush() or any callbacks, which is useful if your program is in a state where such callbacks are illegal. ">Fl::ready()</a> does not.</p>
<p>The idle callback can call any FLTK functions, including <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a>, <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0). ">Fl::check()</a>, and <a class="el" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f" title="This is similar to Fl::check() except this does not call Fl::flush() or any callbacks, which is useful if your program is in a state where such callbacks are illegal. ">Fl::ready()</a>.</p>
<p>FLTK will not recursively call the idle callback. </p>

</div>
</div>
<a id="a23e63eb7cec3a27fa360e66c6e2b2e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e63eb7cec3a27fa360e66c6e2b2e52">&#9670;&nbsp;</a></span>add_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::add_timeout </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a one-shot timeout callback. </p>
<p>The function will be called by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> at <em>t</em> seconds after this function is called. The optional void* argument is passed to the callback.</p>
<p>You can have multiple timeout callbacks. To remove a timeout callback use <a class="el" href="classFl.html#a9a950f0585de6416eb4fee2365a1578f" title="Removes a timeout callback. ">Fl::remove_timeout()</a>.</p>
<p>If you need more accurate, repeated timeouts, use <a class="el" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628" title="Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate ti...">Fl::repeat_timeout()</a> to reschedule the subsequent timeouts.</p>
<p>The following code will print "TICK" each second on stdout with a fair degree of accuracy:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Fl_8H.html">FL/Fl.H</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Fl__Window_8H.html">FL/Fl_Window.H</a>&gt;</span></div><div class="line"><span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {</div><div class="line">  printf(<span class="stringliteral">&quot;TICK\n&quot;</span>);</div><div class="line">  <a class="code" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628">Fl::repeat_timeout</a>(1.0, callback);    <span class="comment">// retrigger timeout</span></div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="code" href="classFl__Window.html">Fl_Window</a> win(100,100);</div><div class="line">  win.show();</div><div class="line">  <a class="code" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52">Fl::add_timeout</a>(1.0, callback);       <span class="comment">// set up first timeout</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classFl.html#a7a3b1236b41800d24267288c564b187a">Fl::run</a>();</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a7600b0ef3dcd4311850ab4b2988d5d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7600b0ef3dcd4311850ab4b2988d5d6d">&#9670;&nbsp;</a></span>api_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::api_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the compiled-in value of the FL_API_VERSION constant. </p>
<p>This is useful for checking the version of a shared library. </p>

</div>
</div>
<a id="a1576b8c9ca3e900daaa5c36ca0e7ae48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1576b8c9ca3e900daaa5c36ca0e7ae48">&#9670;&nbsp;</a></span>arg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a single switch from <code>argv</code>, starting at word <code>i</code>. </p>
<p>Returns the number of words eaten (1 or 2, or 0 if it is not recognized) and adds the same value to <code>i</code>.</p>
<p>This is the default argument handler used internally by <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler. ">Fl::args</a>(...), but you can use this function if you prefer to step through the standard FLTK switches yourself.</p>
<p>All standard FLTK switches except -bg2 may be abbreviated to just one letter and case is ignored:</p>
<ul>
<li>-bg color or -background color <br />
 Sets the background color using <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>.</li>
</ul>
<ul>
<li>-bg2 color or -background2 color <br />
 Sets the secondary background color using <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color. ">Fl::background2()</a>.</li>
</ul>
<ul>
<li>-display host:n.n <br />
 Sets the X display to use; this option is silently ignored under Windows and MacOS.</li>
</ul>
<ul>
<li>-dnd and -nodnd <br />
 Enables or disables drag and drop text operations using <a class="el" href="classFl.html#aae157def51e4dabe5f75298b676ddea2" title="Gets whether drag and drop text operations are supported. ">Fl::dnd_text_ops()</a>.</li>
</ul>
<ul>
<li>-fg color or -foreground color <br />
 Sets the foreground color using <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR). ">Fl::foreground()</a>.</li>
</ul>
<ul>
<li>-geometry WxH+X+Y <br />
 Sets the initial window position and size according to the standard X geometry string.</li>
</ul>
<ul>
<li>-iconic <br />
 Iconifies the window using <a class="el" href="classFl__Window.html#a473a9728b4275ce16347e74faafb3cde" title="Iconifies the window. ">Fl_Window::iconize()</a>.</li>
</ul>
<ul>
<li>-kbd and -nokbd <br />
 Enables or disables visible keyboard focus for non-text widgets using <a class="el" href="classFl.html#ae9eaddd02a0aa637078ee2dd80b85b2f" title="Gets or sets the visible keyboard focus on buttons and other non-text widgets. ">Fl::visible_focus()</a>.</li>
</ul>
<ul>
<li>-name string <br />
 Sets the window class using <a class="el" href="classFl__Window.html#a5f4838ae3f1100495d1f4eeca6c33397" title="Returns the xclass for this window, or a default. ">Fl_Window::xclass()</a>.</li>
</ul>
<ul>
<li>-scheme string <br />
 Sets the widget scheme using <a class="el" href="classFl.html#a48e0d5ea99335d7e4cdcf45d8dbe68b7" title="See void scheme(const char *name) ">Fl::scheme()</a>.</li>
</ul>
<ul>
<li>-title string <br />
 Sets the window title using <a class="el" href="classFl__Window.html#acabd7585709d6627a6b7d8f8eef72c66" title="See void Fl_Window::label(const char*) ">Fl_Window::label()</a>.</li>
</ul>
<ul>
<li>-tooltips and -notooltips <br />
 Enables or disables tooltips using <a class="el" href="classFl__Tooltip.html#aad7ec1340800ab9d883a035118f20995" title="Enables tooltips on all widgets (or disables if b is false). ">Fl_Tooltip::enable()</a>.</li>
</ul>
<p>If your program requires other switches in addition to the standard FLTK options, you will need to pass your own argument handler to <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler. ">Fl::args(int,char**,int&amp;,Fl_Args_Handler)</a> explicitly. </p>

</div>
</div>
<a id="a115903daf3593748cdd36a5e78e74534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115903daf3593748cdd36a5e78e74534">&#9670;&nbsp;</a></span>args() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga6cb5354ccaa2a6619f2408dbb5203f3b">Fl_Args_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse command line switches using the <code>cb</code> argument handler. </p>
<p>Returns 0 on error, or the number of words processed.</p>
<p>FLTK provides this as an <em>entirely optional</em> command line switch parser. You don't have to call it if you don't want to. Everything it can do can be done with other calls to FLTK.</p>
<p>To use the switch parser, call <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler. ">Fl::args</a>(...) near the start of your program. This does <b>not</b> open the display, instead switches that need the display open are stashed into static variables. Then you <b>must</b> display your first window by calling <code>window-&gt;show(argc,argv)</code>, which will do anything stored in the static variables.</p>
<p>Providing an argument handler callback <code>cb</code> lets you define your own switches. It is called with the same <code>argc</code> and <code>argv</code>, and with <code>i</code> set to the index of the switch to be processed. The <code>cb</code> handler should return zero if the switch is unrecognized, and not change <code>i</code>. It should return non-zero to indicate the number of words processed if the switch is recognized, i.e. 1 for just the switch, and more than 1 for the switch plus associated parameters. <code>i</code> should be incremented by the same amount.</p>
<p>The <code>cb</code> handler is called <b>before</b> any other tests, so <em>you can also override any standard FLTK switch</em> (this is why FLTK can use very short switches instead of the long ones all other toolkits force you to use). See <a class="el" href="classFl.html#a1576b8c9ca3e900daaa5c36ca0e7ae48" title="Parse a single switch from argv, starting at word i. ">Fl::arg()</a> for descriptions of the standard switches.</p>
<p>On return <code>i</code> is set to the index of the first non-switch. This is either:</p>
<ul>
<li>The first word that does not start with '-'. </li>
<li>The word '-' (used by many programs to name stdin as a file) </li>
<li>The first unrecognized switch (return value is 0). </li>
<li><code>argc</code> </li>
</ul>
<p>The return value is <code>i</code> unless an unrecognized switch is found, in which case it is zero. If your program takes no arguments other than switches you should produce an error if the return value is less than <code>argc</code>.</p>
<p>A usage string is displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler. ">Fl::args()</a> detects an invalid argument on the command-line. You can change the message by setting the <a class="el" href="classFl.html#a64d41edd7d962116d86a9db810210f7b" title="Usage string displayed if Fl::args() detects an invalid argument. ">Fl::help</a> pointer.</p>
<p>A very simple command line parser can be found in <code>examples/howto-parse-args.cxx</code></p>
<p>The simpler <a class="el" href="classFl.html#a6fb24179ad2642412f4042863fe23645" title="Parse all command line switches matching standard FLTK options only. ">Fl::args(int argc, char **argv)</a> form is useful if your program does not have command line switches of its own. </p>

</div>
</div>
<a id="a6fb24179ad2642412f4042863fe23645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb24179ad2642412f4042863fe23645">&#9670;&nbsp;</a></span>args() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse all command line switches matching standard FLTK options only. </p>
<p>It parses all the switches, and if any are not recognized it calls Fl::abort(Fl::help), i.e. unlike the long form, an unrecognized switch generates an error message and causes the program to exit. </p>

</div>
</div>
<a id="a422da0dfc6aa51721e7c9a6ccf5b90ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422da0dfc6aa51721e7c9a6ccf5b90ef">&#9670;&nbsp;</a></span>background()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to black to white. </p>
<p>These are the colors used as backgrounds by almost all widgets and used to draw the edges of all the boxtypes. </p>

</div>
</div>
<a id="a98d4c4557a2127bfc46abe15feed3be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d4c4557a2127bfc46abe15feed3be2">&#9670;&nbsp;</a></span>background2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::background2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the alternative background color. </p>
<p>This color is used as a background by <a class="el" href="classFl__Input.html" title="This is the FLTK text input widget. ">Fl_Input</a> and other text widgets. </p>
<p>This call may change fl_color(FL_FOREGROUND_COLOR) if it does not provide sufficient contrast to FL_BACKGROUND2_COLOR. </p>

</div>
</div>
<a id="a426f19d77abf3a13b98930095a987bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426f19d77abf3a13b98930095a987bbb">&#9670;&nbsp;</a></span>box_border_radius_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::box_border_radius_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum border radius of all "rounded" boxtypes in pixels. </p>
<dl class="section since"><dt>Since</dt><dd>1.4.0 </dd></dl>

</div>
</div>
<a id="a654c4fb93b0487c5b590c4fc9f1e8aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654c4fb93b0487c5b590c4fc9f1e8aee">&#9670;&nbsp;</a></span>box_border_radius_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::box_border_radius_max </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum border radius of all "rounded" boxtypes in pixels. </p>
<p>Must be at least 5, default = 15.</p>
<dl class="section note"><dt>Note</dt><dd>This does <b>not</b> apply to the "round" boxtypes which have really round sides (i.e. composed of half circles) as opposed to "rounded" boxtypes that have only rounded corners with a straight border between corners.</dd></dl>
<p>The box border radius of "rounded" boxtypes is typically calculated as about 2/5 of the box height or width, whichever is smaller. The upper limit can be set by this method for all "rounded" boxtypes. </p><dl class="section since"><dt>Since</dt><dd>1.4.0 </dd></dl>

</div>
</div>
<a id="aaaecb51f270a5b42ad31f0e8091635dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaecb51f270a5b42ad31f0e8091635dd">&#9670;&nbsp;</a></span>box_color()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a> Fl::box_color </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the drawing color to be used for the background of a box. </p>
<p>This method is only useful inside box drawing code. It returns the color to be used, either fl_inactive(c) if the widget is inactive_r() or <code>c</code> otherwise. </p>

</div>
</div>
<a id="af739a06d44dc94d09015ed1940b9f066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af739a06d44dc94d09015ed1940b9f066">&#9670;&nbsp;</a></span>box_dh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the height offset for the given boxtype. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype. ">box_dy()</a>. </dd></dl>

</div>
</div>
<a id="a9a327ed95a8c2533ca4eee659bf3d557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a327ed95a8c2533ca4eee659bf3d557">&#9670;&nbsp;</a></span>box_dw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the width offset for the given boxtype. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype. ">box_dy()</a>. </dd></dl>

</div>
</div>
<a id="a2971f20fe3595fd8f77fe73d4eb89594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2971f20fe3595fd8f77fe73d4eb89594">&#9670;&nbsp;</a></span>box_dx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the X offset for the given boxtype. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15" title="Returns the Y offset for the given boxtype. ">box_dy()</a> </dd></dl>

</div>
</div>
<a id="a9fbd0a2a5c43a30893dec05e8d34dc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbd0a2a5c43a30893dec05e8d34dc15">&#9670;&nbsp;</a></span>box_dy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::box_dy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Y offset for the given boxtype. </p>
<p>These functions return the offset values necessary for a given boxtype, useful for computing the area inside a box's borders, to prevent overdrawing the borders.</p>
<p>For instance, in the case of a boxtype like FL_DOWN_BOX where the border width might be 2 pixels all around, the above functions would return 2, 2, 4, and 4 for box_dx, box_dy, box_dw, and box_dh respectively.</p>
<p>An example to compute the area inside a widget's box(): </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> X = yourwidget-&gt;x() + <a class="code" href="classFl.html#a2971f20fe3595fd8f77fe73d4eb89594">Fl::box_dx</a>(yourwidget-&gt;box());</div><div class="line"><span class="keywordtype">int</span> Y = yourwidget-&gt;y() + <a class="code" href="classFl.html#a9fbd0a2a5c43a30893dec05e8d34dc15">Fl::box_dy</a>(yourwidget-&gt;box());</div><div class="line"><span class="keywordtype">int</span> W = yourwidget-&gt;w() - <a class="code" href="classFl.html#a9a327ed95a8c2533ca4eee659bf3d557">Fl::box_dw</a>(yourwidget-&gt;box());</div><div class="line"><span class="keywordtype">int</span> H = yourwidget-&gt;h() - <a class="code" href="classFl.html#af739a06d44dc94d09015ed1940b9f066">Fl::box_dh</a>(yourwidget-&gt;box());</div></div><!-- fragment --><p> These functions are mainly useful in the draw() code for deriving custom widgets, where one wants to avoid drawing over the widget's own border box(). </p>

</div>
</div>
<a id="a4fd8ae7763ccae17628af3e49c00a9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd8ae7763ccae17628af3e49c00a9ec">&#9670;&nbsp;</a></span>box_shadow_width() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::box_shadow_width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the box shadow width of all "shadow" boxtypes in pixels. </p>
<dl class="section since"><dt>Since</dt><dd>1.4.0 </dd></dl>

</div>
</div>
<a id="acfefd9ca200dcc16d9ed7e46d54ce626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfefd9ca200dcc16d9ed7e46d54ce626">&#9670;&nbsp;</a></span>box_shadow_width() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::box_shadow_width </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the box shadow width of all "shadow" boxtypes in pixels. </p>
<p>Must be at least 1, default = 3. There is no upper limit. </p><dl class="section since"><dt>Since</dt><dd>1.4.0 </dd></dl>

</div>
</div>
<a id="a1dbb83f1d52001c152ccf8415e3ee6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbb83f1d52001c152ccf8415e3ee6f0">&#9670;&nbsp;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as Fl::wait(0). </p>
<p>Calling this during a big calculation will keep the screen up to date and the interface responsive:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (!calculation_done()) {</div><div class="line">calculate();</div><div class="line"><a class="code" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0">Fl::check</a>();</div><div class="line"><span class="keywordflow">if</span> (user_hit_abort_button()) <span class="keywordflow">break</span>;</div><div class="line">}</div></div><!-- fragment --><p>This returns non-zero if any windows are displayed, and 0 if no windows are displayed (this is likely to change in future versions of FLTK). </p>

</div>
</div>
<a id="ac5e4de1119ebb169c8a8de4c81a4cb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e4de1119ebb169c8a8de4c81a4cb59">&#9670;&nbsp;</a></span>damage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::damage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true then <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">flush()</a> will do something. </p>

</div>
</div>
<a id="a7c6847e1b7dd9628821656933ca8e79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6847e1b7dd9628821656933ca8e79d">&#9670;&nbsp;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::display </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the X display to use for all windows. </p>
<p>Actually this just sets the environment variable $DISPLAY to the passed string, so this only works before you show() the first window or otherwise open the display.</p>
<p>This does nothing on other platforms. </p>

</div>
</div>
<a id="a53430e25b53f3b608193fa4009898463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53430e25b53f3b608193fa4009898463">&#9670;&nbsp;</a></span>dnd_text_ops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::dnd_text_ops </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether drag and drop text operations are supported. </p>
<p>This specifically affects whether selected text can be dragged from text fields or dragged within a text field as a cut/paste shortcut. </p>

</div>
</div>
<a id="aae157def51e4dabe5f75298b676ddea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae157def51e4dabe5f75298b676ddea2">&#9670;&nbsp;</a></span>dnd_text_ops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::dnd_text_ops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether drag and drop text operations are supported. </p>
<p>This returns whether selected text can be dragged from text fields or dragged within a text field as a cut/paste shortcut. </p>

</div>
</div>
<a id="ad56cf568ee94318b50d2b2da0aa3031b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56cf568ee94318b50d2b2da0aa3031b">&#9670;&nbsp;</a></span>draw_box_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::draw_box_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the currently drawn box is active or inactive. </p>
<p>If inactive, the box color should be changed to the inactive color.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#aaaecb51f270a5b42ad31f0e8091635dd" title="Gets the drawing color to be used for the background of a box. ">Fl::box_color(Fl_Color c)</a> </dd></dl>

</div>
</div>
<a id="a8ee84c3cdff0dec085bf666c7d062499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee84c3cdff0dec085bf666c7d062499">&#9670;&nbsp;</a></span>draw_GL_text_with_textures() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::draw_GL_text_with_textures </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets whether OpenGL uses textures to draw all text. </p>
<p>By default, FLTK draws OpenGL text using textures, if the necessary hardware support is available. Call <code>Fl::draw_GL_text_with_textures(0)</code> once in your program before the first call to <a class="el" href="gl_8h.html#afa19d919d46e9e3226a034c93f195591" title="Sets the current OpenGL font to the same font as calling fl_font(). ">gl_font()</a> to have FLTK draw instead OpenGL text using a legacy, platform-dependent procedure. It's recommended not to deactivate textures under the MacOS platform because the MacOS legacy procedure is extremely rudimentary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>use 0 to prevent FLTK from drawing GL text with textures </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="gl_8h.html#abeffd22a2a41b9beb41debb20e70e077" title="Changes the maximum height of the pile of pre-computed string textures. ">gl_texture_pile_height(int max)</a> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.4.0 </dd></dl>

</div>
</div>
<a id="a297d9a7b41053abd23423fa7b2e3b3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297d9a7b41053abd23423fa7b2e3b3ad">&#9670;&nbsp;</a></span>draw_GL_text_with_textures() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::draw_GL_text_with_textures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether whether OpenGL uses textures to draw all text. </p>
<p>Default is yes. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a8ee84c3cdff0dec085bf666c7d062499" title="sets whether OpenGL uses textures to draw all text. ">draw_GL_text_with_textures(int val)</a> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.4.0 </dd></dl>

</div>
</div>
<a id="a08d29d807ea3874b8bb16f7457f64bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d29d807ea3874b8bb16f7457f64bdc">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes all the windows that need it to be redrawn and graphics forced out through the pipes. </p>
<p>This is what <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">wait()</a> does before looking for events.</p>
<p>Note: in multi-threaded applications you should only call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> from the main thread. If a child thread needs to trigger a redraw event, it should instead call <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">Fl::awake()</a> to get the main thread to process the event queue. </p>

</div>
</div>
<a id="afbf02f998cce7ebb3331def57fccc8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf02f998cce7ebb3331def57fccc8a7">&#9670;&nbsp;</a></span>foreground()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::foreground </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes fl_color(FL_FOREGROUND_COLOR). </p>

</div>
</div>
<a id="a837ed3f58be4ad9ed3949e31678bc8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837ed3f58be4ad9ed3949e31678bc8fe">&#9670;&nbsp;</a></span>get_awake_handler_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::get_awake_handler_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga28b44ff2052ca0b06d0da852fadd42c0">Fl_Awake_Handler</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the last stored awake handler for use in <a class="el" href="group__fl__multithread.html#gae9e8f440ce2ca05b047c620f75af13cb" title="Sends a message pointer to the main thread, causing any pending Fl::wait() call to terminate so that ...">awake()</a>. </p>

</div>
</div>
<a id="a62d53b0d7749d7c3d053e72ee2a5a816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d53b0d7749d7c3d053e72ee2a5a816">&#9670;&nbsp;</a></span>get_boxtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__callback__functions.html#gacb24a62f521a0e02cd7872a3bfbf3855">Fl_Box_Draw_F</a> * Fl::get_boxtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current box drawing function for the specified box type. </p>

</div>
</div>
<a id="aed0a7958eebf1491685040be87490947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0a7958eebf1491685040be87490947">&#9670;&nbsp;</a></span>get_system_colors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::get_system_colors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the user preference colors from the system and use them to call <a class="el" href="classFl.html#afbf02f998cce7ebb3331def57fccc8a7" title="Changes fl_color(FL_FOREGROUND_COLOR). ">Fl::foreground()</a>, <a class="el" href="classFl.html#a422da0dfc6aa51721e7c9a6ccf5b90ef" title="Changes fl_color(FL_BACKGROUND_COLOR) to the given color, and changes the gray ramp from 32 to 56 to ...">Fl::background()</a>, and <a class="el" href="classFl.html#a98d4c4557a2127bfc46abe15feed3be2" title="Changes the alternative background color. ">Fl::background2()</a>. </p>
<p>This is done by Fl_Window::show(argc,argv) before applying the -fg and -bg switches.</p>
<p>On X this reads some common values from the Xdefaults database. KDE users can set these values by running the "krdb" program, and newer versions of KDE set this automatically if you check the "apply
style to other X programs" switch in their control panel. </p>

</div>
</div>
<a id="a7a149f42db33b581e1dbe47ffb626abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a149f42db33b581e1dbe47ffb626abf">&#9670;&nbsp;</a></span>gl_visual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::gl_visual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>alist</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does the same thing as <a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly. ">Fl::visual(int)</a> but also requires OpenGL drawing to work. </p>
<p>This <em>must</em> be done if you want to draw in normal windows with OpenGL with <a class="el" href="gl_8h.html#a9c922d784b80b39b0e64c8f4cfb5d123" title="Creates an OpenGL context. ">gl_start()</a> and gl_end(). It may be useful to call this so your X windows use the same visual as an <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works. ">Fl_Gl_Window</a>, which on some servers will reduce colormap flashing.</p>
<p>See <a class="el" href="classFl__Gl__Window.html" title="The Fl_Gl_Window widget sets things up so OpenGL works. ">Fl_Gl_Window</a> for a list of additional values for the argument. </p>

</div>
</div>
<a id="ac203e6ef8108d4a9de6008d4b536307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac203e6ef8108d4a9de6008d4b536307e">&#9670;&nbsp;</a></span>insertion_point_location()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::insertion_point_location </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets window coordinates and height of insertion point. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__events.html#ga79b619b0bccac6da8cdc55e6bb8a8d52" title="Any text editing widget should call this for each FL_KEYBOARD event. ">Fl::compose(int&amp; del)</a> for a detailed description. </dd></dl>

</div>
</div>
<a id="a19c26018ae654d07ec1aa73e35b244a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c26018ae654d07ec1aa73e35b244a4">&#9670;&nbsp;</a></span>is_scheme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::is_scheme </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the current scheme is the given name. </p>
<p>This is a fast inline convenience function to support scheme-specific code in widgets, e.g. in their draw() methods, if required.</p>
<p>Use a valid scheme name, not <code>NULL</code> (although <code>NULL</code> is allowed, this is not a useful argument - see below).</p>
<p>If <a class="el" href="classFl.html#a48e0d5ea99335d7e4cdcf45d8dbe68b7" title="See void scheme(const char *name) ">Fl::scheme()</a> has not been set or has been set to the default scheme ("none" or "base"), then this will always return 0 regardless of the argument, because <a class="el" href="classFl.html#a48e0d5ea99335d7e4cdcf45d8dbe68b7" title="See void scheme(const char *name) ">Fl::scheme()</a> is <code>NULL</code> in this case.</p>
<dl class="section note"><dt>Note</dt><dd>The stored scheme name is always lowercase, and this method will do a case-sensitive compare, so you <b>must</b> provide a lowercase string to return the correct value. This is intentional for performance reasons.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classFl.html#a19c26018ae654d07ec1aa73e35b244a4">Fl::is_scheme</a>(<span class="stringliteral">&quot;gtk+&quot;</span>)) { your_code_here(); }</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td><b>lowercase</b> string of requested scheme name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the given scheme is active, 0 otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a9d070bb1d5a24c28beab53a70af095a4" title="Sets the current widget scheme. ">Fl::scheme(const char *name)</a> </dd></dl>

</div>
</div>
<a id="ab2d29df12fea1b116d70e237eb471798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d29df12fea1b116d70e237eb471798">&#9670;&nbsp;</a></span>menu_linespacing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::menu_linespacing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the default line spacing used by menus. </p>
<dl class="section return"><dt>Returns</dt><dd>The default line spacing, in pixels. </dd></dl>

</div>
</div>
<a id="a6eaabff6af047485f864dbc66cf5978d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaabff6af047485f864dbc66cf5978d">&#9670;&nbsp;</a></span>menu_linespacing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::menu_linespacing </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>H</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default line spacing used by menus. </p>
<p>Default is 4. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>The new default line spacing between menu items, in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc49722be45fb56cad89c7c067eda5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc49722be45fb56cad89c7c067eda5e3">&#9670;&nbsp;</a></span>option() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Fl::option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a>&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FLTK library options management. </p>
<p>This function needs to be documented in more detail. It can be used for more optional settings, such as using a native file chooser instead of the FLTK one wherever possible, disabling tooltips, disabling visible focus, disabling FLTK file chooser preview, etc. .</p>
<p>There should be a command line option interface.</p>
<p>There should be an application that manages options system wide, per user, and per application.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ( <a class="code" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">Fl::option</a>(<a class="code" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">Fl::OPTION_ARROW_FOCUS</a>) )</div><div class="line">    { ..on..  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">    { ..off..  }</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As of FLTK 1.3.0, options can be managed within fluid, using the menu <em>Edit/Global FLTK Settings</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>which option </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d" title="Enumerator for global FLTK options. ">Fl::Fl_Option</a> </dd>
<dd>
<a class="el" href="classFl.html#a9b040cad5d6fc04bb139877015091c16" title="Override an option while the application is running. ">Fl::option(Fl_Option, bool)</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>FLTK 1.3.0 </dd></dl>

</div>
</div>
<a id="a9b040cad5d6fc04bb139877015091c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b040cad5d6fc04bb139877015091c16">&#9670;&nbsp;</a></span>option() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d">Fl_Option</a>&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override an option while the application is running. </p>
<p>This function does not change any system or user settings.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">Fl::option</a>(<a class="code" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">Fl::OPTION_ARROW_FOCUS</a>, <span class="keyword">true</span>);     <span class="comment">// on</span></div><div class="line"><a class="code" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3">Fl::option</a>(<a class="code" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1da0d10867528510b82613c085e6240ebf6">Fl::OPTION_ARROW_FOCUS</a>, <span class="keyword">false</span>);    <span class="comment">// off</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>which option </td></tr>
    <tr><td class="paramname">val</td><td>set to true or false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>enum <a class="el" href="classFl.html#a43e6e0bbbc03cad134d928d4edd48d1d" title="Enumerator for global FLTK options. ">Fl::Fl_Option</a> </dd>
<dd>
bool <a class="el" href="classFl.html#abc49722be45fb56cad89c7c067eda5e3" title="FLTK library options management. ">Fl::option(Fl_Option)</a> </dd></dl>

</div>
</div>
<a id="a217dd709bed0d62a652625d505918fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217dd709bed0d62a652625d505918fc6">&#9670;&nbsp;</a></span>own_colormap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::own_colormap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes FLTK use its <a href="fltk-colormap.png">own colormap</a>. </p>
<p>This may make FLTK display better and will reduce conflicts with other programs that want lots of colors. However the colors may flash as you move the cursor between windows.</p>
<p>This does nothing if the current visual is not colormapped. </p>

</div>
</div>
<a id="a2e47798ab952686bc084e061a4a88da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e47798ab952686bc084e061a4a88da7">&#9670;&nbsp;</a></span>program_should_quit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::program_should_quit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns non-zero when a request for program termination was received and accepted. </p>
<p>On the MacOS platform, the "Quit xxx" item of the application menu is such a request, that is considered accepted when all windows are closed. On other platforms, this function returns 0 until <code>Fl::program_should_quit(1)</code> is called. </p><dl class="section version"><dt>Version</dt><dd>1.4.0 </dd></dl>

</div>
</div>
<a id="a7f75f8111bd47ba00f2b0888831dbd8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f75f8111bd47ba00f2b0888831dbd8c">&#9670;&nbsp;</a></span>program_should_quit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::program_should_quit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>should_i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate to the FLTK library whether a program termination request was received and accepted. </p>
<p>A program may set this to 1, for example, while performing a platform-independent command asking the program to cleanly terminate, similarly to the "Quit xxx" item of the application menu under MacOS. </p><dl class="section version"><dt>Version</dt><dd>1.4.0 </dd></dl>

</div>
</div>
<a id="a3c27ca2833030aa15482bd06dbfc5959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c27ca2833030aa15482bd06dbfc5959">&#9670;&nbsp;</a></span>readqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFl__Widget.html">Fl_Widget</a> * Fl::readqueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the default callback queue and returns the first widget. </p>
<p>All Fl_Widgets that don't have a callback defined use the default callback <code>static</code> <a class="el" href="classFl__Widget.html#a0e926c64eb81dbc6d9dc76ff0dc95e02" title="The default callback for all widgets that don&#39;t set a callback. ">Fl_Widget::default_callback()</a> that puts a pointer to the widget in a queue. This method reads the oldest widget out of this queue.</p>
<p>The queue (FIFO) is limited (currently 20 items). If the queue overflows, the oldest entry (<a class="el" href="classFl__Widget.html" title="Fl_Widget is the base class for all widgets in FLTK. ">Fl_Widget</a> *) is discarded.</p>
<p>Relying on the default callback and reading the callback queue with <a class="el" href="classFl.html#a3c27ca2833030aa15482bd06dbfc5959" title="Reads the default callback queue and returns the first widget. ">Fl::readqueue()</a> is not recommended. If you need a callback, you should set one with <a class="el" href="classFl__Widget.html#ad5fe4ff0d0f777af13f3d8818c869689" title="Sets the current callback function for the widget. ">Fl_Widget::callback(Fl_Callback *cb, void *data)</a> or one of its variants.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl__Widget.html#ac32acdcfb3b722fccd2d3f946b01e799" title="Gets the current callback function for the widget. ">Fl_Widget::callback()</a> </dd>
<dd>
<a class="el" href="classFl__Widget.html#ad5fe4ff0d0f777af13f3d8818c869689" title="Sets the current callback function for the widget. ">Fl_Widget::callback(Fl_Callback *cb, void *data)</a> </dd>
<dd>
<a class="el" href="classFl__Widget.html#a0e926c64eb81dbc6d9dc76ff0dc95e02" title="The default callback for all widgets that don&#39;t set a callback. ">Fl_Widget::default_callback()</a> </dd></dl>

</div>
</div>
<a id="a41a0cf2dd925cc6c4074d32a36fcf98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a0cf2dd925cc6c4074d32a36fcf98f">&#9670;&nbsp;</a></span>ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is similar to <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0). ">Fl::check()</a> except this does <em>not</em> call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> or any callbacks, which is useful if your program is in a state where such callbacks are illegal. </p>
<p>This returns true if <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0). ">Fl::check()</a> would do anything (it will continue to return true until you call <a class="el" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0" title="Same as Fl::wait(0). ">Fl::check()</a> or <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a>).</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (!calculation_done()) {</div><div class="line">  calculate();</div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="classFl.html#a41a0cf2dd925cc6c4074d32a36fcf98f">Fl::ready</a>()) {</div><div class="line">    do_expensive_cleanup();</div><div class="line">    <a class="code" href="classFl.html#a1dbb83f1d52001c152ccf8415e3ee6f0">Fl::check</a>();</div><div class="line">    <span class="keywordflow">if</span> (user_hit_abort_button()) <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a656023b0db49ae9b88e277ccdb27ce1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656023b0db49ae9b88e277ccdb27ce1b">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the current grabbed window, equals grab(0). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use Fl::grab(0) instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__windows.html#ga0918f4dabb87b5e429ad4e0e38239845" title="Selects the window to grab. ">grab(Fl_Window*)</a> </dd></dl>

</div>
</div>
<a id="a3cf6b5b7bfe06b268e8c51ec11acf378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf6b5b7bfe06b268e8c51ec11acf378">&#9670;&nbsp;</a></span>reload_scheme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::reload_scheme </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by scheme according to scheme name. </p>
<p>Loads or reloads the current scheme selection. See void <a class="el" href="classFl.html#a9d070bb1d5a24c28beab53a70af095a4" title="Sets the current widget scheme. ">scheme(const char *name)</a> </p>

</div>
</div>
<a id="a43ee3d6bb1c70f5202e7cc9cb87cd515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee3d6bb1c70f5202e7cc9cb87cd515">&#9670;&nbsp;</a></span>remove_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::remove_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a check callback. </p>
<p>It is harmless to remove a check callback that no longer exists. </p>

</div>
</div>
<a id="a71e75c1a559e3415c5304c37235af831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e75c1a559e3415c5304c37235af831">&#9670;&nbsp;</a></span>remove_fd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::remove_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>when</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a file descriptor handler. </p>

</div>
</div>
<a id="a5f4ece44a4e07f7d95950b665047a807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4ece44a4e07f7d95950b665047a807">&#9670;&nbsp;</a></span>remove_fd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::remove_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a file descriptor handler. </p>

</div>
</div>
<a id="a9a950f0585de6416eb4fee2365a1578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a950f0585de6416eb4fee2365a1578f">&#9670;&nbsp;</a></span>remove_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::remove_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a timeout callback. </p>
<p>It is harmless to remove a timeout callback that no longer exists.</p>
<dl class="section note"><dt>Note</dt><dd>This version removes all matching timeouts, not just the first one. This may change in the future. </dd></dl>

</div>
</div>
<a id="ae5373d1d50c2b0ba38280d78bb6d2628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5373d1d50c2b0ba38280d78bb6d2628">&#9670;&nbsp;</a></span>repeat_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::repeat_timeout </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga17b5c6570394124287997166a50ff07a">Fl_Timeout_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeats a timeout callback from the expiration of the previous timeout, allowing for more accurate timing. </p>
<p>You may only call this method inside a timeout callback of the same timer or at least a closely related timer, otherwise the timing accuracy can't be improved and the behavior is undefined.</p>
<p>The following code will print "TICK" each second on stdout with a fair degree of accuracy:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> callback(<span class="keywordtype">void</span>*) {</div><div class="line">  puts(<span class="stringliteral">&quot;TICK&quot;</span>);</div><div class="line">  <a class="code" href="classFl.html#ae5373d1d50c2b0ba38280d78bb6d2628">Fl::repeat_timeout</a>(1.0, callback);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="code" href="classFl.html#a23e63eb7cec3a27fa360e66c6e2b2e52">Fl::add_timeout</a>(1.0, callback);</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classFl.html#a7a3b1236b41800d24267288c564b187a">Fl::run</a>();</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="afe815086e4f0173700a90bfafd64ab9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe815086e4f0173700a90bfafd64ab9f">&#9670;&nbsp;</a></span>reset_marked_text()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::reset_marked_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets marked text. </p>
<p>In many languages, typing a character can involve multiple keystrokes. For example, the Ä can be composed of two dots (¨) on top of the character, followed by the letter A (on a Mac with U.S. keyboard, you'd type Alt-U, Shift-A. To inform the user that the dots may be followed by another character, the ¨ is underlined).</p>
<p>Call this function if character composition needs to be aborted for some reason. One such example would be the text input widget losing focus. </p>

</div>
</div>
<a id="a7a3b1236b41800d24267288c564b187a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3b1236b41800d24267288c564b187a">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a>repeatedly as long as any windows are displayed. </p>
<p>When all the windows are closed it returns zero (supposedly it would return non-zero on any errors, but FLTK calls exit directly for these). A normal program will end main() with return <a class="el" href="classFl.html#a7a3b1236b41800d24267288c564b187a" title="Calls Fl::wait()repeatedly as long as any windows are displayed. ">Fl::run()</a>;.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classFl.html#a7a3b1236b41800d24267288c564b187a" title="Calls Fl::wait()repeatedly as long as any windows are displayed. ">Fl::run()</a> and <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> (but not <a class="el" href="classFl.html#af49654e35a0b636aa751dce5ff88a7f5" title="Waits a maximum of time_to_wait seconds or until &quot;something happens&quot;. ">Fl::wait(double)</a>) both return when all FLTK windows are closed. Therefore, a MacOS FLTK application possessing <a class="el" href="classFl__Sys__Menu__Bar.html" title="A class to create and modify menus that appear on macOS in the menu bar at the top of the screen...">Fl_Sys_Menu_Bar</a> items able to create new windows and expected to keep running without any open window cannot use these two functions. One solution is to run the event loop as follows: <div class="fragment"><div class="line"><span class="keywordflow">while</span> (!<a class="code" href="classFl.html#a2e47798ab952686bc084e061a4a88da7">Fl::program_should_quit</a>()) <a class="code" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312">Fl::wait</a>(1e20); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9d070bb1d5a24c28beab53a70af095a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d070bb1d5a24c28beab53a70af095a4">&#9670;&nbsp;</a></span>scheme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::scheme </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current widget scheme. </p>
<p>NULL will use the scheme defined in the FLTK_SCHEME environment variable or the scheme resource under X11. Otherwise, any of the following schemes can be used: </p><pre class="fragment">- "none" - This is the default look-n-feel which resembles old
           Windows (95/98/Me/NT/2000) and old GTK/KDE

- "base" - This is an alias for "none"

- "plastic" - This scheme is inspired by the Aqua user interface
              on Mac OS X

- "gtk+" - This scheme is inspired by the Red Hat Bluecurve theme

- "gleam" - This scheme is inspired by the Clearlooks Glossy scheme.
            (Colin Jones and Edmanuel Torres).
</pre><p>Uppercase scheme names are equivalent, but the stored scheme name will always be lowercase and <a class="el" href="classFl.html#a48e0d5ea99335d7e4cdcf45d8dbe68b7" title="See void scheme(const char *name) ">Fl::scheme()</a> will return this lowercase name.</p>
<p>If the resulting scheme name is not defined, the default scheme will be used and <a class="el" href="classFl.html#a48e0d5ea99335d7e4cdcf45d8dbe68b7" title="See void scheme(const char *name) ">Fl::scheme()</a> will return NULL.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a19c26018ae654d07ec1aa73e35b244a4" title="Returns whether the current scheme is the given name. ">Fl::is_scheme()</a> </dd></dl>

</div>
</div>
<a id="a82c225037f05d07a7797da5eddafb33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c225037f05d07a7797da5eddafb33a">&#9670;&nbsp;</a></span>scrollbar_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::scrollbar_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the default scrollbar size used by <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers. ">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text. ">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window...">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget. ">Fl_Text_Display</a> widgets. </p>
<dl class="section return"><dt>Returns</dt><dd>The default size for widget scrollbars, in pixels. </dd></dl>

</div>
</div>
<a id="aa6d2b6e0d640b81c6ec44d0164ec0f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d2b6e0d640b81c6ec44d0164ec0f91">&#9670;&nbsp;</a></span>scrollbar_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::scrollbar_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>W</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default scrollbar size that is used by the <a class="el" href="classFl__Browser__.html" title="This is the base class for browsers. ">Fl_Browser_</a>, <a class="el" href="classFl__Help__View.html" title="The Fl_Help_View widget displays HTML text. ">Fl_Help_View</a>, <a class="el" href="classFl__Scroll.html" title="This container widget lets you maneuver around a set of widgets much larger than your window...">Fl_Scroll</a>, and <a class="el" href="classFl__Text__Display.html" title="Rich text display widget. ">Fl_Text_Display</a> widgets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>The new default size for widget scrollbars, in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae41fc4e972e6c2056529e0d393141147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41fc4e972e6c2056529e0d393141147">&#9670;&nbsp;</a></span>set_box_color()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::set_box_color </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#a8b762953646f8abee866061f1af78a6a">Fl_Color</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the drawing color for the box that is currently drawn. </p>
<p>This method sets the current drawing color <a class="el" href="group__fl__attributes.html#ga974e9f64959aa83cf6f0a36d3f0105aa" title="Sets the color for all subsequent drawing operations. ">fl_color()</a> depending on the widget's state to either <code>c</code> or fl_inactive(c).</p>
<p>It should be used whenever a box background is drawn in the box (type) drawing code instead of calling <a class="el" href="group__fl__attributes.html#ga974e9f64959aa83cf6f0a36d3f0105aa" title="Sets the color for all subsequent drawing operations. ">fl_color(Fl_Color bg)</a> with the background color <code>bg</code>, usually <a class="el" href="classFl__Widget.html#a0f4654d4d9aab8a1c1078fca5660742a" title="Gets the background color of the widget. ">Fl_Widget::color()</a>.</p>
<p>This method is only useful inside box drawing code. Whenever a box is drawn with one of the standard box drawing methods, a static variable is set depending on the widget's current state - if the widget is inactive_r() then the internal variable is false (0), otherwise it is true (1). This is faster than calling <a class="el" href="classFl__Widget.html#a25ebd158cb9f7ccfa7b4cf3406c2b603" title="Returns whether the widget and all of its parents are active. ">Fl_Widget::active_r()</a> because the state is cached.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#ad56cf568ee94318b50d2b2da0aa3031b" title="Determines if the currently drawn box is active or inactive. ">Fl::draw_box_active()</a> </dd>
<dd>
<a class="el" href="classFl.html#aaaecb51f270a5b42ad31f0e8091635dd" title="Gets the drawing color to be used for the background of a box. ">Fl::box_color(Fl_Color)</a> </dd></dl>

</div>
</div>
<a id="a73e0e8fefe8707817ca6fd6437c4869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e0e8fefe8707817ca6fd6437c4869b">&#9670;&nbsp;</a></span>set_boxtype() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::set_boxtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#gacb24a62f521a0e02cd7872a3bfbf3855">Fl_Box_Draw_F</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fl__types_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the function to call to draw a specific boxtype. </p>

</div>
</div>
<a id="a337397ba0fb948633c83ad7c39a67e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337397ba0fb948633c83ad7c39a67e00">&#9670;&nbsp;</a></span>set_boxtype() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::set_boxtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ae48bf9070f8541de17829f54ccacc6bc">Fl_Boxtype</a>&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the from boxtype. </p>

</div>
</div>
<a id="a77955ad2f2b83fc5e3925b94e4533b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77955ad2f2b83fc5e3925b94e4533b20">&#9670;&nbsp;</a></span>set_idle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::set_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga238786923bf2e91732a7305fc0647dbf">Fl_Old_Idle_Handler</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an idle callback. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This method is obsolete - use the <a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a" title="Adds a callback function that is called every time by Fl::wait() and also makes it act as though the ...">add_idle()</a> method instead. </dd></dl>

</div>
</div>
<a id="a2041799ff3f57f4cced52d7e3b3a544a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2041799ff3f57f4cced52d7e3b3a544a">&#9670;&nbsp;</a></span>set_labeltype() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Fl::set_labeltype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga569530b250a4e2f56022249512687a0c">Fl_Label_Draw_F</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__callback__functions.html#ga946140c0dcd42dbef9f134af6f2da17b">Fl_Label_Measure_F</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the functions to call to draw and measure a specific labeltype. </p>

</div>
</div>
<a id="ad1633da3e36598ebe875f0c16fc9f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1633da3e36598ebe875f0c16fc9f198">&#9670;&nbsp;</a></span>set_labeltype() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::set_labeltype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Enumerations_8H.html#ad5774781d33328b82990ff9e25dfd61b">Fl_Labeltype</a>&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the functions to call to draw and measure a specific labeltype. </p>

</div>
</div>
<a id="a3f52e1de14ecab5166a921640fbee640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f52e1de14ecab5166a921640fbee640">&#9670;&nbsp;</a></span>use_high_res_GL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::use_high_res_GL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets whether GL windows should be drawn at high resolution on Apple computers with retina displays </p>
<dl class="section version"><dt>Version</dt><dd>1.3.4 </dd></dl>

</div>
</div>
<a id="a841e929912f3604e0a3d0ef1dff245c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841e929912f3604e0a3d0ef1dff245c8">&#9670;&nbsp;</a></span>use_high_res_GL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::use_high_res_GL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether GL windows should be drawn at high resolution on Apple computers with retina displays. </p>
<p>Default is no. </p><dl class="section version"><dt>Version</dt><dd>1.3.4 </dd></dl>

</div>
</div>
<a id="ad65803adc5e4936111bd31a52f1d61a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65803adc5e4936111bd31a52f1d61a7">&#9670;&nbsp;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Fl::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the compiled-in value of the FL_VERSION constant. </p>
<p>This is useful for checking the version of a shared library.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use int <a class="el" href="classFl.html#a7600b0ef3dcd4311850ab4b2988d5d6d" title="Returns the compiled-in value of the FL_API_VERSION constant. ">Fl::api_version()</a> instead. </dd></dl>

</div>
</div>
<a id="ade5fd097d36257dce2b7aff1165e037f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5fd097d36257dce2b7aff1165e037f">&#9670;&nbsp;</a></span>visible_focus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fl::visible_focus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the visible keyboard focus on buttons and other non-text widgets. </p>
<p>The default mode is to enable keyboard focus for all widgets. </p>

</div>
</div>
<a id="ae9eaddd02a0aa637078ee2dd80b85b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9eaddd02a0aa637078ee2dd80b85b2f">&#9670;&nbsp;</a></span>visible_focus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Fl::visible_focus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or sets the visible keyboard focus on buttons and other non-text widgets. </p>
<p>The default mode is to enable keyboard focus for all widgets. </p>

</div>
</div>
<a id="a6d6deb3d4f76b538d508b36700dfb6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6deb3d4f76b538d508b36700dfb6b0">&#9670;&nbsp;</a></span>visual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::visual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects a visual so that your graphics are drawn correctly. </p>
<p>This is only allowed before you call show() on any windows. This does nothing if the default visual satisfies the capabilities, or if no visual satisfies the capabilities, or on systems that don't have such brain-dead notions.</p>
<p>Only the following combinations do anything useful:</p>
<ul>
<li>
Fl::visual(FL_RGB) <br />
Full/true color (if there are several depths FLTK chooses the largest). Do this if you use fl_draw_image for much better (non-dithered) output. <br />
&#160;  </li>
<li>
Fl::visual(FL_RGB8) <br />
Full color with at least 24 bits of color. FL_RGB will always pick this if available, but if not it will happily return a less-than-24 bit deep visual. This call fails if 24 bits are not available. <br />
&#160;  </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly. ">Fl::visual</a>(FL_DOUBLE|FL_INDEX) <br />
Hardware double buffering. Call this if you are going to use <a class="el" href="classFl__Double__Window.html" title="The Fl_Double_Window provides a double-buffered window. ">Fl_Double_Window</a>. <br />
&#160;  </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly. ">Fl::visual</a>(FL_DOUBLE|FL_RGB) </li>
<li>
<a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0" title="Selects a visual so that your graphics are drawn correctly. ">Fl::visual</a>(FL_DOUBLE|FL_RGB8) <br />
Hardware double buffering and full color. </li>
</ul>
<p>This returns true if the system has the capabilities by default or FLTK succeeded in turning them on. Your program will still work even if this returns false (it just won't look as good). </p>

</div>
</div>
<a id="a108a84216f0b3fa1cb0c46ab7449a312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108a84216f0b3fa1cb0c46ab7449a312">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Fl::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until "something happens" and then returns. </p>
<p>Call this repeatedly to "run" your program. You can also check what happened each time after this returns, which is quite useful for managing program state.</p>
<p>What this really does is call all idle callbacks, all elapsed timeouts, call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc" title="Causes all the windows that need it to be redrawn and graphics forced out through the pipes...">Fl::flush()</a> to get the screen to update, and then wait some time (zero if there are idle callbacks, the shortest of all pending timeouts, or infinity), for any events from the user or any <a class="el" href="classFl.html#a8905e303e45e846b8ce77168f4cf7afe" title="Adds file descriptor fd to listen to. ">Fl::add_fd()</a> callbacks. It then handles the events and calls the callbacks and then returns.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero if there are any visible windows - this may change in future versions of FLTK. </dd></dl>

</div>
</div>
<a id="af49654e35a0b636aa751dce5ff88a7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49654e35a0b636aa751dce5ff88a7f5">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Fl::wait </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_to_wait</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits a maximum of <code>time_to_wait</code> seconds or until "something happens". </p>
<p>See <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312" title="Waits until &quot;something happens&quot; and then returns. ">Fl::wait()</a> for the description of operations performed when "something happens". </p><dl class="section return"><dt>Returns</dt><dd>Always 1 on Windows. Otherwise, it is positive if an event or fd happens before the time elapsed. It is zero if nothing happens. It is negative if an error occurs (this will happen on X11 if a signal happens). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a64d41edd7d962116d86a9db810210f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d41edd7d962116d86a9db810210f7b">&#9670;&nbsp;</a></span>help</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char *const Fl::help = helpmsg+13</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Usage string displayed if <a class="el" href="classFl.html#a115903daf3593748cdd36a5e78e74534" title="Parse command line switches using the cb argument handler. ">Fl::args()</a> detects an invalid argument. </p>
<p>This may be changed to point to customized text at run-time. </p>

</div>
</div>
<a id="a60fb2b446096dd4742511edb459653d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fb2b446096dd4742511edb459653d3">&#9670;&nbsp;</a></span>idle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void(* Fl::idle)()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently executing idle callback function: DO NOT USE THIS DIRECTLY! </p>
<p>This is now used as part of a higher level system allowing multiple idle callback functions to be called. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classFl.html#a4e7a1b5d18c2f073238a8466a62a3e7a" title="Adds a callback function that is called every time by Fl::wait() and also makes it act as though the ...">add_idle()</a>, <a class="el" href="classFl.html#a43903f998a07e1cca7ba199c8ed25d9b" title="Removes the specified idle callback, if it is installed. ">remove_idle()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Fl_8H_source.html">Fl.H</a></li>
<li><a class="el" href="Fl_8cxx.html">Fl.cxx</a></li>
<li>Fl_abort.cxx</li>
<li>Fl_add_idle.cxx</li>
<li>Fl_arg.cxx</li>
<li><a class="el" href="fl__boxtype_8cxx.html">fl_boxtype.cxx</a></li>
<li><a class="el" href="fl__color_8cxx.html">fl_color.cxx</a></li>
<li><a class="el" href="Fl__compose_8cxx.html">Fl_compose.cxx</a></li>
<li>Fl_display.cxx</li>
<li>Fl_get_system_colors.cxx</li>
<li>Fl_grab.cxx</li>
<li>fl_labeltype.cxx</li>
<li>Fl_lock.cxx</li>
<li>Fl_own_colormap.cxx</li>
<li>fl_set_font.cxx</li>
<li>fl_shortcut.cxx</li>
<li>Fl_visual.cxx</li>
<li>Fl_Widget.cxx</li>
<li>Fl_Window.cxx</li>
<li>screen_xywh.cxx</li>
<li>Fl_Cairo.cxx</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->

    <li class="footer">
      <!-- Generated for FLTK by Doxygen -->
      &copy; 1998-2020 by Bill Spitzak and others. &nbsp;&nbsp;&nbsp;
      <a href="https://www.fltk.org"><img src="tiny.png" align="bottom" alt="FLTK"></a>
     </li>
   </ul>
 </div>
</body>
</html>
